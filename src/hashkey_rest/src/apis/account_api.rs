/*
 * Hashkey Exchange
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_v1_account_asset_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountAssetTransferPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_balance_flow_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountBalanceFlowGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_check_api_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountCheckApiKeyGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_fiat_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountFiatHistoryGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountTradesGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountTypesGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_vip_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountVipInfoGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}


/// Internal asset account transfer
pub async fn api_v1_account_asset_transfer_post(configuration: &configuration::Configuration, from_account_id: &str, to_account_id: &str, coin: &str, quantity: f64, timestamp: i64, signature: &str, asset_transfer_request: models::AssetTransferRequest, remark: Option<&str>, client_order_id: Option<&str>) -> Result<models::AssetTransferResponse, Error<ApiV1AccountAssetTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_account_id = from_account_id;
    let p_to_account_id = to_account_id;
    let p_coin = coin;
    let p_quantity = quantity;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_asset_transfer_request = asset_transfer_request;
    let p_remark = remark;
    let p_client_order_id = client_order_id;

    let uri_str = format!("{}/api/v1/account/assetTransfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("fromAccountId", &p_from_account_id.to_string())]);
    req_builder = req_builder.query(&[("toAccountId", &p_to_account_id.to_string())]);
    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    req_builder = req_builder.query(&[("quantity", &p_quantity.to_string())]);
    if let Some(ref param_value) = p_remark {
        req_builder = req_builder.query(&[("remark", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_order_id {
        req_builder = req_builder.query(&[("clientOrderId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_asset_transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountAssetTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <ul> <li>Only master account Master API key can call this interface, sub-accounts will return insufficient prvilege type error code</li><li>All orders returned are final</li><li> Deposit, Withdrawal failed will not be return Query of trade history supports the past 7 days time range. The other types support maximum 30 days. Exceeded amount will return error code \"Exceed maximum time range of N days\"</li><li> Remark can only support up to 128 characters</li>
pub async fn api_v1_account_balance_flow_get(configuration: &configuration::Configuration, r#type: &str, start_time: i64, end_time: i64, timestamp: i64, signature: &str, account_id: Option<i64>, client_order_id: Option<&str>, remark: Option<&str>, begin_id: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::BalanceFlowResponseInner>, Error<ApiV1AccountBalanceFlowGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_account_id = account_id;
    let p_client_order_id = client_order_id;
    let p_remark = remark;
    let p_begin_id = begin_id;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v1/account/balanceFlow", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_client_order_id {
        req_builder = req_builder.query(&[("clientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_remark {
        req_builder = req_builder.query(&[("remark", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("startTime", &p_start_time.to_string())]);
    req_builder = req_builder.query(&[("endTime", &p_end_time.to_string())]);
    if let Some(ref param_value) = p_begin_id {
        req_builder = req_builder.query(&[("beginId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountBalanceFlowGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get API Key Type
pub async fn api_v1_account_check_api_key_get(configuration: &configuration::Configuration, timestamp: i64) -> Result<models::CheckApiKeyResponse, Error<ApiV1AccountCheckApiKeyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;

    let uri_str = format!("{}/api/v1/account/checkApiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountCheckApiKeyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Fiat History
pub async fn api_v1_account_fiat_history_get(configuration: &configuration::Configuration, r#type: &str, start_time: i64, end_time: i64, timestamp: i64, signature: &str, status: Option<&str>, channel: Option<&str>, remark: Option<&str>, limit: Option<i32>, recv_window: Option<i64>) -> Result<models::HistoryResponse, Error<ApiV1AccountFiatHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_status = status;
    let p_channel = channel;
    let p_remark = remark;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v1/account/fiat/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("startTime", &p_start_time.to_string())]);
    req_builder = req_builder.query(&[("endTime", &p_end_time.to_string())]);
    if let Some(ref param_value) = p_channel {
        req_builder = req_builder.query(&[("channel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_remark {
        req_builder = req_builder.query(&[("remark", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountFiatHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve Account balance
pub async fn api_v1_account_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, account_id: Option<i64>) -> Result<models::AccountBalanceResponse, Error<ApiV1AccountGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_account_id = account_id;

    let uri_str = format!("{}/api/v1/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query account history and transaction records <br> <ul> <li> If there is only fromId, It will return trades with IDs bigger than fromId, sorted in descending order.</li> <li> If there is only toId. It will return trades with IDs less than toId, sorted in descending order</li> <li> If both fromId and toId are provided. It will return trades between fromId and toId, sorted in descending order</li> <li> If neither fromId or toId is provided, it will return the latest trade records, sorted in descending order.</li> </ul>
pub async fn api_v1_account_trades_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, symbol: Option<&str>, start_time: Option<i64>, end_time: Option<i64>, client_order_id: Option<&str>, from_id: Option<i64>, to_id: Option<i64>, limit: Option<i32>, account_id: Option<i64>) -> Result<models::TransactionQueryResponse, Error<ApiV1AccountTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_symbol = symbol;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_client_order_id = client_order_id;
    let p_from_id = from_id;
    let p_to_id = to_id;
    let p_limit = limit;
    let p_account_id = account_id;

    let uri_str = format!("{}/api/v1/account/trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_order_id {
        req_builder = req_builder.query(&[("clientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_id {
        req_builder = req_builder.query(&[("fromId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_id {
        req_builder = req_builder.query(&[("toId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get account types.
pub async fn api_v1_account_types_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str) -> Result<models::AccountTypesResponse, Error<ApiV1AccountTypesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v1/account/types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountTypesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve VIP Level and Trading fee rates
pub async fn api_v1_account_vip_info_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, symbol: Option<&str>) -> Result<models::TradingResponse, Error<ApiV1AccountVipInfoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_symbol = symbol;

    let uri_str = format!("{}/api/v1/account/vipInfo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountVipInfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

