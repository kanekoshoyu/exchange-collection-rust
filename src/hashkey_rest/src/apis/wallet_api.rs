/*
 * Hashkey Exchange
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_v1_account_deposit_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountDepositAddressGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_deposit_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountDepositOrdersGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_deposit_refund_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountDepositRefundPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_fiat_withdraw_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountFiatWithdrawPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_whitelist_verify_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountWhitelistVerifyGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_whitelist_whitelist_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountWhitelistWhitelistAddressGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_withdraw_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountWithdrawOrdersGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_account_withdraw_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AccountWithdrawPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}


/// Retrieve deposit address generated by the system
pub async fn api_v1_account_deposit_address_get(configuration: &configuration::Configuration, coin: &str, chain_type: &str, timestamp: i64, signature: &str, wallet_id: Option<&str>) -> Result<models::DepositInformationResponse, Error<ApiV1AccountDepositAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_chain_type = chain_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_wallet_id = wallet_id;

    let uri_str = format!("{}/api/v1/account/deposit/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    req_builder = req_builder.query(&[("chainType", &p_chain_type.to_string())]);
    if let Some(ref param_value) = p_wallet_id {
        req_builder = req_builder.query(&[("walletId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountDepositAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Deposit History
pub async fn api_v1_account_deposit_orders_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, coin: Option<&str>, start_time: Option<i64>, end_time: Option<i64>, from_id: Option<i32>, wallet_id: Option<&str>, limit: Option<i32>) -> Result<models::DepositHistoryResponse, Error<ApiV1AccountDepositOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_coin = coin;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_from_id = from_id;
    let p_wallet_id = wallet_id;
    let p_limit = limit;

    let uri_str = format!("{}/api/v1/account/depositOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_id {
        req_builder = req_builder.query(&[("fromId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_wallet_id {
        req_builder = req_builder.query(&[("walletId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountDepositOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deposit refunds
pub async fn api_v1_account_deposit_refund_post(configuration: &configuration::Configuration, deposit_refund_request: models::DepositRefundRequest) -> Result<bool, Error<ApiV1AccountDepositRefundPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_deposit_refund_request = deposit_refund_request;

    let uri_str = format!("{}/api/v1/account/depositRefund", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_deposit_refund_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountDepositRefundPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Withdraw Fiat
pub async fn api_v1_account_fiat_withdraw_post(configuration: &configuration::Configuration, withdraw_fiat_request: models::WithdrawFiatRequest) -> Result<models::WithdrawFiatResponse, Error<ApiV1AccountFiatWithdrawPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdraw_fiat_request = withdraw_fiat_request;

    let uri_str = format!("{}/api/v1/account/fiat/withdraw", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_withdraw_fiat_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountFiatWithdrawPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Verify Whitelist Address<br>When the request parameter \"quantity\" is specified as the same value, the deposit random amount (Micropayment) will always remain the same. There will be no change unless the specified \"quantity\" value is changed
pub async fn api_v1_account_whitelist_verify_get(configuration: &configuration::Configuration, coin: &str, chain_type: &str, quantity: &str, wallet_id: Option<&str>) -> Result<models::DepositResponse, Error<ApiV1AccountWhitelistVerifyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_chain_type = chain_type;
    let p_quantity = quantity;
    let p_wallet_id = wallet_id;

    let uri_str = format!("{}/api/v1/account/whitelist/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    req_builder = req_builder.query(&[("chainType", &p_chain_type.to_string())]);
    req_builder = req_builder.query(&[("quantity", &p_quantity.to_string())]);
    if let Some(ref param_value) = p_wallet_id {
        req_builder = req_builder.query(&[("walletId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountWhitelistVerifyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Whitelisted Address
pub async fn api_v1_account_whitelist_whitelist_address_get(configuration: &configuration::Configuration, coin: &str, r#type: &str, wallet_id: Option<&str>) -> Result<models::WhitelistResponse, Error<ApiV1AccountWhitelistWhitelistAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_type = r#type;
    let p_wallet_id = wallet_id;

    let uri_str = format!("{}/api/v1/account/whitelist/whitelistAddress", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_wallet_id {
        req_builder = req_builder.query(&[("walletId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountWhitelistWhitelistAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve withdrawal history
pub async fn api_v1_account_withdraw_orders_get(configuration: &configuration::Configuration, timestamp: i64, coin: Option<&str>, start_time: Option<i64>, end_time: Option<i64>, remark: Option<&str>, limit: Option<i32>) -> Result<Vec<models::WithdrawItem>, Error<ApiV1AccountWithdrawOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_coin = coin;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_remark = remark;
    let p_limit = limit;

    let uri_str = format!("{}/api/v1/account/withdrawOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_remark {
        req_builder = req_builder.query(&[("remark", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountWithdrawOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// withdraw request
pub async fn api_v1_account_withdraw_post(configuration: &configuration::Configuration, coin: &str, client_order_id: &str, address: &str, quantity: f64, chain_type: &str, timestamp: i32, asset_transfer_request: models::AssetTransferRequest, address_ext: Option<&str>, remark: Option<&str>, wallet_id: Option<&str>) -> Result<models::AssetTransferResponse, Error<ApiV1AccountWithdrawPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_client_order_id = client_order_id;
    let p_address = address;
    let p_quantity = quantity;
    let p_chain_type = chain_type;
    let p_timestamp = timestamp;
    let p_asset_transfer_request = asset_transfer_request;
    let p_address_ext = address_ext;
    let p_remark = remark;
    let p_wallet_id = wallet_id;

    let uri_str = format!("{}/api/v1/account/withdraw", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    req_builder = req_builder.query(&[("clientOrderId", &p_client_order_id.to_string())]);
    req_builder = req_builder.query(&[("address", &p_address.to_string())]);
    if let Some(ref param_value) = p_address_ext {
        req_builder = req_builder.query(&[("addressExt", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("quantity", &p_quantity.to_string())]);
    req_builder = req_builder.query(&[("chainType", &p_chain_type.to_string())]);
    if let Some(ref param_value) = p_remark {
        req_builder = req_builder.query(&[("remark", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_wallet_id {
        req_builder = req_builder.query(&[("walletId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_asset_transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AccountWithdrawPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

