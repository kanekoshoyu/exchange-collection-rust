/*
 * Hashkey Exchange
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_v11_spot_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV11SpotOrderPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_batch_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotBatchOrdersPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_cancel_order_by_ids_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotCancelOrderByIdsDeleteError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_open_orders_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotOpenOrdersDeleteError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_open_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotOpenOrdersGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_order_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotOrderDeleteError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotOrderGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotOrderPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_order_test_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotOrderTestPostError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_spot_trade_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SpotTradeOrdersGetError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}


/// Creates a single order for Spot Trading on the Exchange. When an order is placed, the required funds from your account will be ringfenced for the duration of the order
pub async fn api_v11_spot_order_post(configuration: &configuration::Configuration, spot_order_request: models::SpotOrderRequest) -> Result<models::SpotOrderResponse, Error<ApiV11SpotOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_spot_order_request = spot_order_request;

    let uri_str = format!("{}/api/v1.1/spot/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_spot_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV11SpotOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create orders in batches up to 20 orders at a time. Currently only support for same symbol
pub async fn api_v1_spot_batch_orders_post(configuration: &configuration::Configuration, batch_order_request_inner: Vec<models::BatchOrderRequestInner>) -> Result<models::BatchOrderResponse, Error<ApiV1SpotBatchOrdersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_batch_order_request_inner = batch_order_request_inner;

    let uri_str = format!("{}/api/v1/spot/batchOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_batch_order_request_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotBatchOrdersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel orders in batches according to order ID (Maximum of 100 orders in a single batch). **Note**:A return code of 0 from the code indicates that the cancel order request has been executed. To determine if it was successful, you need to check the results in the result field. If the result is null, it means all were successful. If it is non empty, theorderId represents the ID of the order that failed to cancel, and code represents the reason for the cancellation failure
pub async fn api_v1_spot_cancel_order_by_ids_delete(configuration: &configuration::Configuration, ids: &str, timestamp: i64) -> Result<models::DeleteMultiOrderResponse, Error<ApiV1SpotCancelOrderByIdsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ids = ids;
    let p_timestamp = timestamp;

    let uri_str = format!("{}/api/v1/spot/cancelOrderByIds", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("ids", &p_ids.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotCancelOrderByIdsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel all open orders
pub async fn api_v1_spot_open_orders_delete(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, side: Option<&str>) -> Result<models::DeleteAllOrderResponse, Error<ApiV1SpotOpenOrdersDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_side = side;

    let uri_str = format!("{}/api/v1/spot/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_side {
        req_builder = req_builder.query(&[("side", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotOpenOrdersDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query current active orders.In regards to master API key. The request parameters of \"side\" and \"accountId\". If \"accountId\" is passed, it will only query the orders under the current account. If not passed, it will first query the main account, and if the results are less than 500, it will then query the sub-accounts.
pub async fn api_v1_spot_open_orders_get(configuration: &configuration::Configuration, timestamp: i64, order_id: Option<i64>, symbol: Option<&str>, side: Option<&str>, limit: Option<i32>) -> Result<models::GetAllOrderResponse, Error<ApiV1SpotOpenOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_order_id = order_id;
    let p_symbol = symbol;
    let p_side = side;
    let p_limit = limit;

    let uri_str = format!("{}/api/v1/spot/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_side {
        req_builder = req_builder.query(&[("side", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotOpenOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an existing order. Either orderId or clientOrderId must be sent.
pub async fn api_v1_spot_order_delete(configuration: &configuration::Configuration, timestamp: i64, order_id: Option<i64>, client_order_id: Option<&str>) -> Result<models::DeleteOrderResponse, Error<ApiV1SpotOrderDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_order_id = order_id;
    let p_client_order_id = client_order_id;

    let uri_str = format!("{}/api/v1/spot/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_order_id {
        req_builder = req_builder.query(&[("clientOrderId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotOrderDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check a single order information
pub async fn api_v1_spot_order_get(configuration: &configuration::Configuration, timestamp: i64, order_id: Option<i64>, orig_client_order_id: Option<&str>, account_id: Option<&str>) -> Result<models::SingleOrderResponse, Error<ApiV1SpotOrderGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_order_id = order_id;
    let p_orig_client_order_id = orig_client_order_id;
    let p_account_id = account_id;

    let uri_str = format!("{}/api/v1/spot/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_orig_client_order_id {
        req_builder = req_builder.query(&[("origClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotOrderGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a single order for Spot Trading on the Exchange. When an order is placed, the required funds from your account will be ringfenced for the duration of the order
pub async fn api_v1_spot_order_post(configuration: &configuration::Configuration, spot_order_request: models::SpotOrderRequest) -> Result<models::SpotOrderResponse, Error<ApiV1SpotOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_spot_order_request = spot_order_request;

    let uri_str = format!("{}/api/v1/spot/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_spot_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submits a validation request to test endpoint
pub async fn api_v1_spot_order_test_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, quantity: f64, price: f64, new_client_order_id: Option<&str>, time_in_force: Option<&str>, recv_window: Option<i64>, timestamp: Option<i64>, signature: Option<&str>, order_test: Option<models::OrderTest>) -> Result<(), Error<ApiV1SpotOrderTestPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_side = side;
    let p_type = r#type;
    let p_quantity = quantity;
    let p_price = price;
    let p_new_client_order_id = new_client_order_id;
    let p_time_in_force = time_in_force;
    let p_recv_window = recv_window;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_order_test = order_test;

    let uri_str = format!("{}/api/v1/spot/orderTest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("side", &p_side.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    req_builder = req_builder.query(&[("quantity", &p_quantity.to_string())]);
    req_builder = req_builder.query(&[("price", &p_price.to_string())]);
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_time_in_force {
        req_builder = req_builder.query(&[("timeInForce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_timestamp {
        req_builder = req_builder.query(&[("timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_signature {
        req_builder = req_builder.query(&[("signature", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_order_test);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotOrderTestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve all traded orders.In regards to master API key. The request parameters of \"side\" and \"accountId\". If \"accountId\" is passed, it will only query the orders under the current account. If not passed, it will first query the main account, and if the results are less than 500, it will then query the sub-accounts
pub async fn api_v1_spot_trade_orders_get(configuration: &configuration::Configuration, symbol: &str, start_time: i64, end_time: i64, timestamp: i64, account_id: Option<&str>, order_id: Option<i64>, side: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderResponse, Error<ApiV1SpotTradeOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_timestamp = timestamp;
    let p_account_id = account_id;
    let p_order_id = order_id;
    let p_side = side;
    let p_limit = limit;

    let uri_str = format!("{}/api/v1/spot/tradeOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("startTime", &p_start_time.to_string())]);
    req_builder = req_builder.query(&[("endTime", &p_end_time.to_string())]);
    if let Some(ref param_value) = p_side {
        req_builder = req_builder.query(&[("side", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1SpotTradeOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

