/*
 * MEXC Crypto Exchange
 *
 * Welcome to mexc API document! 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`create_sub_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubAccountError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sub_account_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubAccountApiKeyError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_sub_account_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubAccountApiKeyError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_api_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountApiKeysError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountListError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universal_transfer_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniversalTransferHistoryError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_sub_account_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuerySubAccountAssetError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`universal_transfer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UniversalTransferError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// This endpoint allows the master account to create a sub-account with a specified name and notes.
pub async fn create_sub_account(configuration: &configuration::Configuration, sub_account: &str, note: &str, timestamp: i32, recv_window: Option<i32>) -> Result<models::CreateSubAccount200Response, Error<CreateSubAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_account = sub_account;
    let p_note = note;
    let p_timestamp = timestamp;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/sub-account/virtualSubAccount", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("subAccount", &p_sub_account.to_string())]);
    req_builder = req_builder.query(&[("note", &p_note.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSubAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint creates an API key for a specified sub-account, with defined permissions and optional IP restrictions.
pub async fn create_sub_account_api_key(configuration: &configuration::Configuration, sub_account: &str, note: &str, permissions: &str, timestamp: i32, ip: Option<&str>, recv_window: Option<i32>) -> Result<models::ApiKey, Error<CreateSubAccountApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_account = sub_account;
    let p_note = note;
    let p_permissions = permissions;
    let p_timestamp = timestamp;
    let p_ip = ip;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/sub-account/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("subAccount", &p_sub_account.to_string())]);
    req_builder = req_builder.query(&[("note", &p_note.to_string())]);
    req_builder = req_builder.query(&[("permissions", &p_permissions.to_string())]);
    if let Some(ref param_value) = p_ip {
        req_builder = req_builder.query(&[("ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSubAccountApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint deletes a specific API key for a given sub-account by providing the sub-account name and the API key to be deleted.
pub async fn delete_sub_account_api_key(configuration: &configuration::Configuration, sub_account: &str, api_key: &str, timestamp: i32, recv_window: Option<i32>) -> Result<models::DeleteSubAccountApiKey200Response, Error<DeleteSubAccountApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_account = sub_account;
    let p_api_key = api_key;
    let p_timestamp = timestamp;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/sub-account/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("subAccount", &p_sub_account.to_string())]);
    req_builder = req_builder.query(&[("apiKey", &p_api_key.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSubAccountApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint retrieves the API keys for a specific sub-account, along with the associated permissions, IP restrictions, and creation time.
pub async fn get_sub_account_api_keys(configuration: &configuration::Configuration, sub_account: &str, timestamp: i32, recv_window: Option<i32>) -> Result<models::ApiKeyList, Error<GetSubAccountApiKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_account = sub_account;
    let p_timestamp = timestamp;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/sub-account/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("subAccount", &p_sub_account.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubAccountApiKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint retrieves the details of sub-accounts under a master account, including information such as sub-account name, freeze status, UID, and creation time.
pub async fn get_sub_account_list(configuration: &configuration::Configuration, timestamp: i32, sub_account: Option<&str>, is_freeze: Option<&str>, page: Option<i32>, limit: Option<i32>, recv_window: Option<i32>) -> Result<models::Subaccounts, Error<GetSubAccountListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_sub_account = sub_account;
    let p_is_freeze = is_freeze;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/sub-account/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_sub_account {
        req_builder = req_builder.query(&[("subAccount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_freeze {
        req_builder = req_builder.query(&[("isFreeze", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubAccountListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint retrieves information on previous universal transfers between sub-accounts and master accounts, including transfer details such as asset, amount, and status.
pub async fn get_universal_transfer_history(configuration: &configuration::Configuration, from_account_type: &str, to_account_type: &str, timestamp: &str, signature: &str, from_account: Option<&str>, to_account: Option<&str>, start_time: Option<&str>, end_time: Option<&str>, page: Option<&str>, limit: Option<&str>) -> Result<models::TransferHistory, Error<GetUniversalTransferHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_account_type = from_account_type;
    let p_to_account_type = to_account_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_from_account = from_account;
    let p_to_account = to_account;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/api/v3/capital/sub-account/universalTransfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_from_account {
        req_builder = req_builder.query(&[("fromAccount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_account {
        req_builder = req_builder.query(&[("toAccount", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("fromAccountType", &p_from_account_type.to_string())]);
    req_builder = req_builder.query(&[("toAccountType", &p_to_account_type.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniversalTransferHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows you to query the asset balances (both free and locked) for a specific sub-account and account type (currently supports SPOT).
pub async fn query_sub_account_asset(configuration: &configuration::Configuration, sub_account: &str, account_type: &str, timestamp: &str, signature: &str) -> Result<models::Assets, Error<QuerySubAccountAssetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_account = sub_account;
    let p_account_type = account_type;
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/sub-account/asset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("subAccount", &p_sub_account.to_string())]);
    req_builder = req_builder.query(&[("accountType", &p_account_type.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<QuerySubAccountAssetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows transferring assets between the master account and sub-accounts, either from or to SPOT or FUTURES accounts.
pub async fn universal_transfer(configuration: &configuration::Configuration, from_account_type: &str, to_account_type: &str, asset: &str, amount: &str, timestamp: &str, signature: &str, from_account: Option<&str>, to_account: Option<&str>) -> Result<models::UniversalTransfer200Response, Error<UniversalTransferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_account_type = from_account_type;
    let p_to_account_type = to_account_type;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_from_account = from_account;
    let p_to_account = to_account;

    let uri_str = format!("{}/api/v3/capital/sub-account/universalTransfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_from_account {
        req_builder = req_builder.query(&[("fromAccount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_account {
        req_builder = req_builder.query(&[("toAccount", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("fromAccountType", &p_from_account_type.to_string())]);
    req_builder = req_builder.query(&[("toAccountType", &p_to_account_type.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UniversalTransferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

