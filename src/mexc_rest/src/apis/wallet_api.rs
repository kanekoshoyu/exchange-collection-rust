/*
 * MEXC Crypto Exchange
 *
 * Welcome to mexc API document! 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`apply_withdrawal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplyWithdrawalError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_withdraw`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelWithdrawError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dust_log_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DustLogQueryError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dust_transfer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DustTransferError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_deposit_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateDepositAddressError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_assets_for_conversion_to_mx`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetsForConversionToMxError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_deposit_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDepositAddressError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_withdraw_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWithdrawAddressError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_transfer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalTransferError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_currency_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryCurrencyInfoError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_deposit_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryDepositHistoryError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_internal_transfer_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryInternalTransferHistoryError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_user_universal_transfer_history_by_tran_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryUserUniversalTransferHistoryByTranIdError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_withdraw_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryWithdrawHistoryError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_universal_transfer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserUniversalTransferError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_universal_transfer_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserUniversalTransferHistoryError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`withdraw_cryptocurrency`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WithdrawCryptocurrencyError {
    Status400(),
    Status401(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// This endpoint allows users to initiate a withdrawal of their assets to a specified address and network.
pub async fn apply_withdrawal(configuration: &configuration::Configuration, coin: &str, address: &str, amount: &str, timestamp: &str, signature: &str, withdraw_order_id: Option<&str>, network: Option<&str>, memo: Option<&str>, remark: Option<&str>) -> Result<models::ApplyWithdrawal200Response, Error<ApplyWithdrawalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_address = address;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_withdraw_order_id = withdraw_order_id;
    let p_network = network;
    let p_memo = memo;
    let p_remark = remark;

    let uri_str = format!("{}/api/v3/capital/withdraw/apply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_withdraw_order_id {
        req_builder = req_builder.query(&[("withdrawOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_network {
        req_builder = req_builder.query(&[("network", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("address", &p_address.to_string())]);
    if let Some(ref param_value) = p_memo {
        req_builder = req_builder.query(&[("memo", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_remark {
        req_builder = req_builder.query(&[("remark", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApplyWithdrawalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows a user to cancel a previously initiated withdrawal request by providing the withdrawal ID.
pub async fn cancel_withdraw(configuration: &configuration::Configuration, id: &str, timestamp: &str, signature: &str) -> Result<models::CancelWithdraw200Response, Error<CancelWithdrawError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/capital/withdraw", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelWithdrawError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to view the history of their dust conversions, including details of each conversion, such as the total amount converted and the associated fees.
pub async fn dust_log_query(configuration: &configuration::Configuration, timestamp: &str, signature: &str, start_time: Option<i64>, end_time: Option<i64>, page: Option<i32>, limit: Option<i32>) -> Result<models::Conversions, Error<DustLogQueryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/api/v3/capital/convert", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DustLogQueryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to convert small amounts of various assets (dust) into a single asset, such as MX, for easier management.
pub async fn dust_transfer(configuration: &configuration::Configuration, asset: &str, timestamp: &str, signature: &str) -> Result<models::Conversion, Error<DustTransferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset = asset;
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/capital/convert", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DustTransferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to generate a deposit address for a specific coin and network. It also provides the necessary memo or tag if applicable.
pub async fn generate_deposit_address(configuration: &configuration::Configuration, coin: &str, network: &str, timestamp: &str, signature: &str) -> Result<Vec<models::DepositAddressInner>, Error<GenerateDepositAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_network = network;
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/capital/deposit/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    req_builder = req_builder.query(&[("network", &p_network.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateDepositAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to retrieve the list of assets that can be converted into MX, along with their balance and conversion details.
pub async fn get_assets_for_conversion_to_mx(configuration: &configuration::Configuration, timestamp: &str, signature: &str) -> Result<Vec<models::ConversionListInner>, Error<GetAssetsForConversionToMxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/capital/convert/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetsForConversionToMxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to get deposit addresses for a specific coin and network. It returns the available deposit addresses and any associated memo (if applicable).
pub async fn get_deposit_address(configuration: &configuration::Configuration, coin: &str, timestamp: &str, signature: &str, network: Option<&str>) -> Result<Vec<models::AddressInner>, Error<GetDepositAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_network = network;

    let uri_str = format!("{}/api/v3/capital/deposit/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_network {
        req_builder = req_builder.query(&[("network", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDepositAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to get withdrawal addresses for a specific coin and network. It returns available withdrawal addresses, associated address tags (if applicable), and any memo (if required).
pub async fn get_withdraw_address(configuration: &configuration::Configuration, timestamp: &str, signature: &str, coin: Option<&str>, page: Option<i32>, limit: Option<i32>) -> Result<models::WithdrawHistory, Error<GetWithdrawAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_coin = coin;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/api/v3/capital/withdraw/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWithdrawAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to transfer assets to another account, identified by email, UID, or mobile number.
pub async fn internal_transfer(configuration: &configuration::Configuration, to_account_type: &str, to_account: &str, asset: &str, amount: &str, timestamp: &str, signature: &str, area_code: Option<&str>) -> Result<models::InternalTransfer200Response, Error<InternalTransferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_to_account_type = to_account_type;
    let p_to_account = to_account;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_area_code = area_code;

    let uri_str = format!("{}/api/v3/capital/transfer/internal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("toAccountType", &p_to_account_type.to_string())]);
    req_builder = req_builder.query(&[("toAccount", &p_to_account.to_string())]);
    if let Some(ref param_value) = p_area_code {
        req_builder = req_builder.query(&[("areaCode", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalTransferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint retrieves detailed information about various currencies, including withdrawal and deposit capabilities, network details, and smart contract addresses.
pub async fn query_currency_info(configuration: &configuration::Configuration, ) -> Result<Vec<models::CapitalInner>, Error<QueryCurrencyInfoError>> {

    let uri_str = format!("{}/api/v3/capital/config/getall", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryCurrencyInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to query their deposit history, including coin details, network, status, and other information.
pub async fn query_deposit_history(configuration: &configuration::Configuration, timestamp: &str, signature: &str, coin: Option<&str>, status: Option<&str>, start_time: Option<&str>, end_time: Option<&str>, limit: Option<&str>) -> Result<Vec<models::DepositInner>, Error<QueryDepositHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_coin = coin;
    let p_status = status;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;

    let uri_str = format!("{}/api/v3/capital/deposit/hisrec", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryDepositHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint returns the history of internal transfers for the specified time range or based on `tranId`.
pub async fn query_internal_transfer_history(configuration: &configuration::Configuration, timestamp: &str, signature: &str, start_time: Option<&str>, end_time: Option<&str>, page: Option<i32>, limit: Option<i32>, tran_id: Option<&str>) -> Result<models::InternalTransfer, Error<QueryInternalTransferHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;
    let p_tran_id = tran_id;

    let uri_str = format!("{}/api/v3/capital/transfer/internal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tran_id {
        req_builder = req_builder.query(&[("tranId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryInternalTransferHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to query a specific transfer record by its `tranId`.
pub async fn query_user_universal_transfer_history_by_tran_id(configuration: &configuration::Configuration, tran_id: &str, timestamp: &str, signature: &str) -> Result<models::Transfers, Error<QueryUserUniversalTransferHistoryByTranIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tran_id = tran_id;
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/capital/transfer/tranId", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tranId", &p_tran_id.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryUserUniversalTransferHistoryByTranIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to query their withdrawal history for a specific coin. It supports filtering by coin type, withdrawal status, and time range.
pub async fn query_withdraw_history(configuration: &configuration::Configuration, timestamp: &str, signature: &str, coin: Option<&str>, status: Option<&str>, limit: Option<&str>, start_time: Option<&str>, end_time: Option<&str>) -> Result<Vec<models::HistoryInner>, Error<QueryWithdrawHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_coin = coin;
    let p_status = status;
    let p_limit = limit;
    let p_start_time = start_time;
    let p_end_time = end_time;

    let uri_str = format!("{}/api/v3/capital/withdraw/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryWithdrawHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to transfer assets between different account types such as \"SPOT\" and \"FUTURES\". It is useful for managing funds across different trading accounts.
pub async fn user_universal_transfer(configuration: &configuration::Configuration, from_account_type: &str, to_account_type: &str, asset: &str, amount: &str, timestamp: &str, signature: &str) -> Result<models::UserUniversalTransfer200Response, Error<UserUniversalTransferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_account_type = from_account_type;
    let p_to_account_type = to_account_type;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/capital/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("fromAccountType", &p_from_account_type.to_string())]);
    req_builder = req_builder.query(&[("toAccountType", &p_to_account_type.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UserUniversalTransferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows users to query the history of their transfers between account types (e.g., from SPOT to FUTURES or vice versa).
pub async fn user_universal_transfer_history(configuration: &configuration::Configuration, from_account_type: &str, to_account_type: &str, timestamp: &str, signature: &str, start_time: Option<&str>, end_time: Option<&str>, page: Option<&str>, size: Option<&str>) -> Result<models::Transfer, Error<UserUniversalTransferHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_account_type = from_account_type;
    let p_to_account_type = to_account_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_size = size;

    let uri_str = format!("{}/api/v3/capital/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fromAccountType", &p_from_account_type.to_string())]);
    req_builder = req_builder.query(&[("toAccountType", &p_to_account_type.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UserUniversalTransferHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint allows a user to withdraw a cryptocurrency to an external address.
pub async fn withdraw_cryptocurrency(configuration: &configuration::Configuration, coin: &str, address: &str, amount: &str, timestamp: &str, signature: &str, withdraw_order_id: Option<&str>, network: Option<&str>, contract_address: Option<&str>, memo: Option<&str>, remark: Option<&str>) -> Result<models::WithdrawCryptocurrency200Response, Error<WithdrawCryptocurrencyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_address = address;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_withdraw_order_id = withdraw_order_id;
    let p_network = network;
    let p_contract_address = contract_address;
    let p_memo = memo;
    let p_remark = remark;

    let uri_str = format!("{}/api/v3/capital/withdraw", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_withdraw_order_id {
        req_builder = req_builder.query(&[("withdrawOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_network {
        req_builder = req_builder.query(&[("network", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_contract_address {
        req_builder = req_builder.query(&[("contractAddress", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("address", &p_address.to_string())]);
    if let Some(ref param_value) = p_memo {
        req_builder = req_builder.query(&[("memo", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_remark {
        req_builder = req_builder.query(&[("remark", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MEXC-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<WithdrawCryptocurrencyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

