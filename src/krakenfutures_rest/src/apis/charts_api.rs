/*
 * Kraken API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_charts_v1_analytics_liquidity_pool_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiChartsV1AnalyticsLiquidityPoolGetError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_charts_v1_analytics_symbol_analytics_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiChartsV1AnalyticsSymbolAnalyticsTypeGetError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_charts_v1_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiChartsV1GetError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_charts_v1_tick_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiChartsV1TickTypeGetError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_charts_v1_tick_type_symbol_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiChartsV1TickTypeSymbolGetError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_charts_v1_tick_type_symbol_resolution_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiChartsV1TickTypeSymbolResolutionGetError {
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


pub async fn api_charts_v1_analytics_liquidity_pool_get(configuration: &configuration::Configuration, since: i64, interval: i32, to: Option<i64>) -> Result<models::PoolStatistics, Error<ApiChartsV1AnalyticsLiquidityPoolGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_since = since;
    let p_interval = interval;
    let p_to = to;

    let uri_str = format!("{}/api/charts/v1/analytics/liquidity-pool", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("since", &p_since.to_string())]);
    req_builder = req_builder.query(&[("interval", &p_interval.to_string())]);
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authent", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("APIKey", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiChartsV1AnalyticsLiquidityPoolGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_charts_v1_analytics_symbol_analytics_type_get(configuration: &configuration::Configuration, symbol: &str, analytics_type: &str, since: i64, interval: i32, to: Option<i32>) -> Result<models::PoolStatistics, Error<ApiChartsV1AnalyticsSymbolAnalyticsTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_analytics_type = analytics_type;
    let p_since = since;
    let p_interval = interval;
    let p_to = to;

    let uri_str = format!("{}/api/charts/v1/analytics/{symbol}/{analytics_type}", configuration.base_path, symbol=crate::apis::urlencode(p_symbol), analytics_type=crate::apis::urlencode(p_analytics_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("since", &p_since.to_string())]);
    req_builder = req_builder.query(&[("interval", &p_interval.to_string())]);
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authent", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("APIKey", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiChartsV1AnalyticsSymbolAnalyticsTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all available tick types to use with the markets endpoint.
pub async fn api_charts_v1_get(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<ApiChartsV1GetError>> {

    let uri_str = format!("{}/api/charts/v1/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authent", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("APIKey", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiChartsV1GetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Markets available for specified tick type.<br>List of available tick types can be fetched from the tick types endpoint.
pub async fn api_charts_v1_tick_type_get(configuration: &configuration::Configuration, tick_type: &str) -> Result<Vec<String>, Error<ApiChartsV1TickTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tick_type = tick_type;

    let uri_str = format!("{}/api/charts/v1/{tick_type}", configuration.base_path, tick_type=crate::apis::urlencode(p_tick_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authent", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("APIKey", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiChartsV1TickTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Candle resolutions available for specified tick type and market.<br>List of available tick types can be fetched from the tick types endpoint. List of available markets can be fetched from the markets endpoint.
pub async fn api_charts_v1_tick_type_symbol_get(configuration: &configuration::Configuration, tick_type: &str, symbol: &str) -> Result<Vec<String>, Error<ApiChartsV1TickTypeSymbolGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tick_type = tick_type;
    let p_symbol = symbol;

    let uri_str = format!("{}/api/charts/v1/{tick_type}/{symbol}", configuration.base_path, tick_type=crate::apis::urlencode(p_tick_type), symbol=crate::apis::urlencode(p_symbol));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authent", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("APIKey", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiChartsV1TickTypeSymbolGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Candles for specified tick type, market, and resolution.<br>List of available tick types can be fetched from the tick types endpoint. List of available markets can be fetched from the markets endpoint. List of available resolutions can be fetched from the resolutions endpoint.
pub async fn api_charts_v1_tick_type_symbol_resolution_get(configuration: &configuration::Configuration, tick_type: &str, symbol: &str, resolution: &str) -> Result<models::Candles, Error<ApiChartsV1TickTypeSymbolResolutionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tick_type = tick_type;
    let p_symbol = symbol;
    let p_resolution = resolution;

    let uri_str = format!("{}/api/charts/v1/{tick_type}/{symbol}/{resolution}", configuration.base_path, tick_type=crate::apis::urlencode(p_tick_type), symbol=crate::apis::urlencode(p_symbol), resolution=crate::apis::urlencode(p_resolution));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authent", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("APIKey", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiChartsV1TickTypeSymbolResolutionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

