/*
 * Coinbase API
 *
 * The Coinbase v2 API (converted from Swagger to OpenAPI by kanekoshoyu)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`accounts_account_id_transactions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAccountIdTransactionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_account_id_transactions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAccountIdTransactionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_account_id_transactions_transaction_id_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAccountIdTransactionsTransactionIdCompletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_account_id_transactions_transaction_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAccountIdTransactionsTransactionIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_account_id_transactions_transaction_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAccountIdTransactionsTransactionIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_account_id_transactions_transaction_id_resend_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAccountIdTransactionsTransactionIdResendPostError {
    UnknownValue(serde_json::Value),
}


/// Lists accountâ€™s transactions. See Transaction resource for more information.
pub async fn accounts_account_id_transactions_get(configuration: &configuration::Configuration, account_id: &str) -> Result<models::AccountsAccountIdAddressesAddressIdTransactionsGet200Response, Error<AccountsAccountIdTransactionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!("{}/accounts/{account_id}/transactions", configuration.base_path, account_id=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAccountIdTransactionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Type=send =========  Send funds to a bitcoin address or email address. No transaction fees are required for off blockchain transactions, and Coinbase waives fees for on-blockchain transactions greater than 0.0001 BTC, up to a threshold of 25 per day. Read more about free transactions.  When used with OAuth2 authentication, this endpoint requires two factor authentication unless used with wallet:transactions:send:bypass-2fa scope.  If the user is able to buy bitcoin, they can send funds from their fiat account using instant exchange feature. Buy fees will be included in the created transaction and the recipient will receive the user defined amount.  To create a multisig transaction, visit Multisig documentation.  Type=request ============  Requests money from an email address. 
pub async fn accounts_account_id_transactions_post(configuration: &configuration::Configuration, account_id: &str, transaction_options: models::AccountsAccountIdTransactionsPostRequest) -> Result<models::AccountsAccountIdTransactionsPost201Response, Error<AccountsAccountIdTransactionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_transaction_options = transaction_options;

    let uri_str = format!("{}/accounts/{account_id}/transactions", configuration.base_path, account_id=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_transaction_options);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAccountIdTransactionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lets the recipient of a money request complete the request by sending money to the user who requested the money. This can only be completed by the user to whom the request was made, not the user who sent the request.
pub async fn accounts_account_id_transactions_transaction_id_complete_post(configuration: &configuration::Configuration, account_id: &str, transaction_id: &str) -> Result<(), Error<AccountsAccountIdTransactionsTransactionIdCompletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_transaction_id = transaction_id;

    let uri_str = format!("{}/accounts/{account_id}/transactions/{transaction_id}/complete", configuration.base_path, account_id=crate::apis::urlencode(p_account_id), transaction_id=crate::apis::urlencode(p_transaction_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAccountIdTransactionsTransactionIdCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lets a user cancel a money request. Money requests can be canceled by the sender or the recipient.
pub async fn accounts_account_id_transactions_transaction_id_delete(configuration: &configuration::Configuration, account_id: &str, transaction_id: &str) -> Result<(), Error<AccountsAccountIdTransactionsTransactionIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_transaction_id = transaction_id;

    let uri_str = format!("{}/accounts/{account_id}/transactions/{transaction_id}", configuration.base_path, account_id=crate::apis::urlencode(p_account_id), transaction_id=crate::apis::urlencode(p_transaction_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAccountIdTransactionsTransactionIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Show an individual transaction for an account. See Transaction resource for more information.
pub async fn accounts_account_id_transactions_transaction_id_get(configuration: &configuration::Configuration, account_id: &str, transaction_id: &str) -> Result<models::AccountsAccountIdTransactionsPost201Response, Error<AccountsAccountIdTransactionsTransactionIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_transaction_id = transaction_id;

    let uri_str = format!("{}/accounts/{account_id}/transactions/{transaction_id}", configuration.base_path, account_id=crate::apis::urlencode(p_account_id), transaction_id=crate::apis::urlencode(p_transaction_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAccountIdTransactionsTransactionIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lets the user resend a money request. This will notify recipient with a new email.
pub async fn accounts_account_id_transactions_transaction_id_resend_post(configuration: &configuration::Configuration, account_id: &str, transaction_id: &str) -> Result<(), Error<AccountsAccountIdTransactionsTransactionIdResendPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_transaction_id = transaction_id;

    let uri_str = format!("{}/accounts/{account_id}/transactions/{transaction_id}/resend", configuration.base_path, account_id=crate::apis::urlencode(p_account_id), transaction_id=crate::apis::urlencode(p_transaction_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAccountIdTransactionsTransactionIdResendPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

