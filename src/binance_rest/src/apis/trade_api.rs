/*
 * Binance Public Spot API
 *
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_v3_account_commission_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AccountCommissionGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_account_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AccountGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_all_order_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AllOrderListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_all_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AllOrdersGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_my_allocations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3MyAllocationsGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_my_prevented_matches_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3MyPreventedMatchesGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_my_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3MyTradesGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_open_order_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OpenOrderListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_open_orders_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OpenOrdersDeleteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_open_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OpenOrdersGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_cancel_replace_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderCancelReplacePostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderDeleteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_list_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderListDeleteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_oco_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderOcoPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_test_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderTestPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_rate_limit_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3RateLimitOrderGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_sor_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3SorOrderPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_sor_order_test_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3SorOrderTestPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}


/// Get current account commission rates.  Weight: 20
pub async fn api_v3_account_commission_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str) -> Result<models::ApiV3AccountCommissionGet200Response, Error<ApiV3AccountCommissionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;

    let uri_str = format!("{}/api/v3/account/commission", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3AccountCommissionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get current account information.  Weight(IP): 20
pub async fn api_v3_account_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::Account, Error<ApiV3AccountGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3AccountGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all OCO based on provided optional parameters  Weight(IP): 20
pub async fn api_v3_all_order_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, from_id: Option<i64>, start_time: Option<i64>, end_time: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::ApiV3AllOrderListGet200ResponseInner>, Error<ApiV3AllOrderListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_from_id = from_id;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/allOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_from_id {
        req_builder = req_builder.query(&[("fromId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3AllOrderListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20
pub async fn api_v3_all_orders_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, start_time: Option<i64>, end_time: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::OrderDetails>, Error<ApiV3AllOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_order_id = order_id;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3AllOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                             Response symbol                                 allocations from oldest to newest symbol + startTime                     oldest allocations since startTime symbol + endTime                       newest allocations until endTime symbol + startTime + endTime           allocations within the time range symbol + fromAllocationId             allocations by allocation ID symbol + orderId                       allocations related to an order starting with oldest symbol + orderId + fromAllocationId   allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.
pub async fn api_v3_my_allocations_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, from_allocation_id: Option<i64>, limit: Option<i32>, order_id: Option<i64>, recv_window: Option<i64>) -> Result<Vec<models::ApiV3MyAllocationsGet200ResponseInner>, Error<ApiV3MyAllocationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_from_allocation_id = from_allocation_id;
    let p_limit = limit;
    let p_order_id = order_id;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/myAllocations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_allocation_id {
        req_builder = req_builder.query(&[("fromAllocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3MyAllocationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                             Weight If symbol is invalid:           2 Querying by preventedMatchId:   2 Querying by orderId:             20
pub async fn api_v3_my_prevented_matches_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, prevented_match_id: Option<i64>, order_id: Option<i64>, from_prevented_match_id: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::ApiV3MyPreventedMatchesGet200ResponseInner>, Error<ApiV3MyPreventedMatchesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_prevented_match_id = prevented_match_id;
    let p_order_id = order_id;
    let p_from_prevented_match_id = from_prevented_match_id;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/myPreventedMatches", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_prevented_match_id {
        req_builder = req_builder.query(&[("preventedMatchId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_prevented_match_id {
        req_builder = req_builder.query(&[("fromPreventedMatchId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3MyPreventedMatchesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20
pub async fn api_v3_my_trades_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, start_time: Option<i64>, end_time: Option<i64>, from_id: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::MyTrade>, Error<ApiV3MyTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_order_id = order_id;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_from_id = from_id;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/myTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_id {
        req_builder = req_builder.query(&[("fromId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3MyTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 6
pub async fn api_v3_open_order_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::ApiV3OpenOrderListGet200ResponseInner>, Error<ApiV3OpenOrderListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/openOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OpenOrderListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1
pub async fn api_v3_open_orders_delete(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::ApiV3OpenOrdersDelete200ResponseInner>, Error<ApiV3OpenOrdersDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OpenOrdersDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;
pub async fn api_v3_open_orders_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, symbol: Option<&str>, recv_window: Option<i64>) -> Result<Vec<models::OrderDetails>, Error<ApiV3OpenOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_symbol = symbol;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OpenOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1
pub async fn api_v3_order_cancel_replace_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, cancel_replace_mode: &str, timestamp: i64, signature: &str, cancel_restrictions: Option<&str>, time_in_force: Option<&str>, quantity: Option<f64>, quote_order_qty: Option<f64>, price: Option<f64>, cancel_new_client_order_id: Option<&str>, cancel_orig_client_order_id: Option<&str>, cancel_order_id: Option<i64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, stop_price: Option<f64>, trailing_delta: Option<f64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderCancelReplacePost200Response, Error<ApiV3OrderCancelReplacePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_side = side;
    let p_type = r#type;
    let p_cancel_replace_mode = cancel_replace_mode;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_cancel_restrictions = cancel_restrictions;
    let p_time_in_force = time_in_force;
    let p_quantity = quantity;
    let p_quote_order_qty = quote_order_qty;
    let p_price = price;
    let p_cancel_new_client_order_id = cancel_new_client_order_id;
    let p_cancel_orig_client_order_id = cancel_orig_client_order_id;
    let p_cancel_order_id = cancel_order_id;
    let p_new_client_order_id = new_client_order_id;
    let p_strategy_id = strategy_id;
    let p_strategy_type = strategy_type;
    let p_stop_price = stop_price;
    let p_trailing_delta = trailing_delta;
    let p_iceberg_qty = iceberg_qty;
    let p_new_order_resp_type = new_order_resp_type;
    let p_self_trade_prevention_mode = self_trade_prevention_mode;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/order/cancelReplace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("side", &p_side.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    req_builder = req_builder.query(&[("cancelReplaceMode", &p_cancel_replace_mode.to_string())]);
    if let Some(ref param_value) = p_cancel_restrictions {
        req_builder = req_builder.query(&[("cancelRestrictions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_time_in_force {
        req_builder = req_builder.query(&[("timeInForce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quantity {
        req_builder = req_builder.query(&[("quantity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quote_order_qty {
        req_builder = req_builder.query(&[("quoteOrderQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cancel_new_client_order_id {
        req_builder = req_builder.query(&[("cancelNewClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cancel_orig_client_order_id {
        req_builder = req_builder.query(&[("cancelOrigClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cancel_order_id {
        req_builder = req_builder.query(&[("cancelOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_id {
        req_builder = req_builder.query(&[("strategyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_type {
        req_builder = req_builder.query(&[("strategyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_price {
        req_builder = req_builder.query(&[("stopPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_trailing_delta {
        req_builder = req_builder.query(&[("trailingDelta", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_iceberg_qty {
        req_builder = req_builder.query(&[("icebergQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_order_resp_type {
        req_builder = req_builder.query(&[("newOrderRespType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_self_trade_prevention_mode {
        req_builder = req_builder.query(&[("selfTradePreventionMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderCancelReplacePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1
pub async fn api_v3_order_delete(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, orig_client_order_id: Option<&str>, new_client_order_id: Option<&str>, cancel_restrictions: Option<&str>, recv_window: Option<i64>) -> Result<models::Order, Error<ApiV3OrderDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_order_id = order_id;
    let p_orig_client_order_id = orig_client_order_id;
    let p_new_client_order_id = new_client_order_id;
    let p_cancel_restrictions = cancel_restrictions;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_orig_client_order_id {
        req_builder = req_builder.query(&[("origClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cancel_restrictions {
        req_builder = req_builder.query(&[("cancelRestrictions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4
pub async fn api_v3_order_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, orig_client_order_id: Option<&str>, recv_window: Option<i64>) -> Result<models::OrderDetails, Error<ApiV3OrderGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_order_id = order_id;
    let p_orig_client_order_id = orig_client_order_id;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_orig_client_order_id {
        req_builder = req_builder.query(&[("origClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1
pub async fn api_v3_order_list_delete(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_list_id: Option<i64>, list_client_order_id: Option<&str>, new_client_order_id: Option<&str>, recv_window: Option<i64>) -> Result<models::OcoOrder, Error<ApiV3OrderListDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_order_list_id = order_list_id;
    let p_list_client_order_id = list_client_order_id;
    let p_new_client_order_id = new_client_order_id;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_order_list_id {
        req_builder = req_builder.query(&[("orderListId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_list_client_order_id {
        req_builder = req_builder.query(&[("listClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderListDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4
pub async fn api_v3_order_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, order_list_id: Option<i64>, orig_client_order_id: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderListGet200Response, Error<ApiV3OrderListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_order_list_id = order_list_id;
    let p_orig_client_order_id = orig_client_order_id;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_list_id {
        req_builder = req_builder.query(&[("orderListId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_orig_client_order_id {
        req_builder = req_builder.query(&[("origClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1
pub async fn api_v3_order_oco_post(configuration: &configuration::Configuration, symbol: &str, side: &str, quantity: f64, price: f64, stop_price: f64, timestamp: i64, signature: &str, list_client_order_id: Option<&str>, limit_client_order_id: Option<&str>, limit_strategy_id: Option<i64>, limit_strategy_type: Option<i64>, limit_iceberg_qty: Option<f64>, trailing_delta: Option<f64>, stop_client_order_id: Option<&str>, stop_strategy_id: Option<i64>, stop_strategy_type: Option<i64>, stop_limit_price: Option<f64>, stop_iceberg_qty: Option<f64>, stop_limit_time_in_force: Option<&str>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderOcoPost200Response, Error<ApiV3OrderOcoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_side = side;
    let p_quantity = quantity;
    let p_price = price;
    let p_stop_price = stop_price;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_list_client_order_id = list_client_order_id;
    let p_limit_client_order_id = limit_client_order_id;
    let p_limit_strategy_id = limit_strategy_id;
    let p_limit_strategy_type = limit_strategy_type;
    let p_limit_iceberg_qty = limit_iceberg_qty;
    let p_trailing_delta = trailing_delta;
    let p_stop_client_order_id = stop_client_order_id;
    let p_stop_strategy_id = stop_strategy_id;
    let p_stop_strategy_type = stop_strategy_type;
    let p_stop_limit_price = stop_limit_price;
    let p_stop_iceberg_qty = stop_iceberg_qty;
    let p_stop_limit_time_in_force = stop_limit_time_in_force;
    let p_new_order_resp_type = new_order_resp_type;
    let p_self_trade_prevention_mode = self_trade_prevention_mode;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/order/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_list_client_order_id {
        req_builder = req_builder.query(&[("listClientOrderId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("side", &p_side.to_string())]);
    req_builder = req_builder.query(&[("quantity", &p_quantity.to_string())]);
    if let Some(ref param_value) = p_limit_client_order_id {
        req_builder = req_builder.query(&[("limitClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit_strategy_id {
        req_builder = req_builder.query(&[("limitStrategyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit_strategy_type {
        req_builder = req_builder.query(&[("limitStrategyType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("price", &p_price.to_string())]);
    if let Some(ref param_value) = p_limit_iceberg_qty {
        req_builder = req_builder.query(&[("limitIcebergQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_trailing_delta {
        req_builder = req_builder.query(&[("trailingDelta", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_client_order_id {
        req_builder = req_builder.query(&[("stopClientOrderId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("stopPrice", &p_stop_price.to_string())]);
    if let Some(ref param_value) = p_stop_strategy_id {
        req_builder = req_builder.query(&[("stopStrategyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_strategy_type {
        req_builder = req_builder.query(&[("stopStrategyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_limit_price {
        req_builder = req_builder.query(&[("stopLimitPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_iceberg_qty {
        req_builder = req_builder.query(&[("stopIcebergQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_limit_time_in_force {
        req_builder = req_builder.query(&[("stopLimitTimeInForce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_order_resp_type {
        req_builder = req_builder.query(&[("newOrderRespType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_self_trade_prevention_mode {
        req_builder = req_builder.query(&[("selfTradePreventionMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderOcoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1
pub async fn api_v3_order_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, timestamp: i64, signature: &str, time_in_force: Option<&str>, quantity: Option<f64>, quote_order_qty: Option<f64>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, stop_price: Option<f64>, trailing_delta: Option<f64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderPost200Response, Error<ApiV3OrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_side = side;
    let p_type = r#type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_time_in_force = time_in_force;
    let p_quantity = quantity;
    let p_quote_order_qty = quote_order_qty;
    let p_price = price;
    let p_new_client_order_id = new_client_order_id;
    let p_strategy_id = strategy_id;
    let p_strategy_type = strategy_type;
    let p_stop_price = stop_price;
    let p_trailing_delta = trailing_delta;
    let p_iceberg_qty = iceberg_qty;
    let p_new_order_resp_type = new_order_resp_type;
    let p_self_trade_prevention_mode = self_trade_prevention_mode;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("side", &p_side.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_time_in_force {
        req_builder = req_builder.query(&[("timeInForce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quantity {
        req_builder = req_builder.query(&[("quantity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quote_order_qty {
        req_builder = req_builder.query(&[("quoteOrderQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_id {
        req_builder = req_builder.query(&[("strategyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_type {
        req_builder = req_builder.query(&[("strategyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_price {
        req_builder = req_builder.query(&[("stopPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_trailing_delta {
        req_builder = req_builder.query(&[("trailingDelta", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_iceberg_qty {
        req_builder = req_builder.query(&[("icebergQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_order_resp_type {
        req_builder = req_builder.query(&[("newOrderRespType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_self_trade_prevention_mode {
        req_builder = req_builder.query(&[("selfTradePreventionMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`
pub async fn api_v3_order_test_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, timestamp: i64, signature: &str, time_in_force: Option<&str>, quantity: Option<f64>, quote_order_qty: Option<f64>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, stop_price: Option<f64>, trailing_delta: Option<f64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, recv_window: Option<i64>, compute_commission_rates: Option<bool>) -> Result<serde_json::Value, Error<ApiV3OrderTestPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_side = side;
    let p_type = r#type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_time_in_force = time_in_force;
    let p_quantity = quantity;
    let p_quote_order_qty = quote_order_qty;
    let p_price = price;
    let p_new_client_order_id = new_client_order_id;
    let p_strategy_id = strategy_id;
    let p_strategy_type = strategy_type;
    let p_stop_price = stop_price;
    let p_trailing_delta = trailing_delta;
    let p_iceberg_qty = iceberg_qty;
    let p_new_order_resp_type = new_order_resp_type;
    let p_recv_window = recv_window;
    let p_compute_commission_rates = compute_commission_rates;

    let uri_str = format!("{}/api/v3/order/test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("side", &p_side.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_time_in_force {
        req_builder = req_builder.query(&[("timeInForce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quantity {
        req_builder = req_builder.query(&[("quantity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quote_order_qty {
        req_builder = req_builder.query(&[("quoteOrderQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_id {
        req_builder = req_builder.query(&[("strategyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_type {
        req_builder = req_builder.query(&[("strategyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_price {
        req_builder = req_builder.query(&[("stopPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_trailing_delta {
        req_builder = req_builder.query(&[("trailingDelta", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_iceberg_qty {
        req_builder = req_builder.query(&[("icebergQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_order_resp_type {
        req_builder = req_builder.query(&[("newOrderRespType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_compute_commission_rates {
        req_builder = req_builder.query(&[("computeCommissionRates", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3OrderTestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Displays the user's current order count usage for all intervals.  Weight(IP): 40
pub async fn api_v3_rate_limit_order_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::ApiV3RateLimitOrderGet200ResponseInner>, Error<ApiV3RateLimitOrderGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/rateLimit/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3RateLimitOrderGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 6
pub async fn api_v3_sor_order_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, quantity: f64, timestamp: i64, signature: &str, time_in_force: Option<&str>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3SorOrderPost200Response, Error<ApiV3SorOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_side = side;
    let p_type = r#type;
    let p_quantity = quantity;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_time_in_force = time_in_force;
    let p_price = price;
    let p_new_client_order_id = new_client_order_id;
    let p_strategy_id = strategy_id;
    let p_strategy_type = strategy_type;
    let p_iceberg_qty = iceberg_qty;
    let p_new_order_resp_type = new_order_resp_type;
    let p_self_trade_prevention_mode = self_trade_prevention_mode;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/sor/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("side", &p_side.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_time_in_force {
        req_builder = req_builder.query(&[("timeInForce", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("quantity", &p_quantity.to_string())]);
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_id {
        req_builder = req_builder.query(&[("strategyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_type {
        req_builder = req_builder.query(&[("strategyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_iceberg_qty {
        req_builder = req_builder.query(&[("icebergQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_order_resp_type {
        req_builder = req_builder.query(&[("newOrderRespType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_self_trade_prevention_mode {
        req_builder = req_builder.query(&[("selfTradePreventionMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3SorOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`
pub async fn api_v3_sor_order_test_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, quantity: f64, timestamp: i64, signature: &str, time_in_force: Option<&str>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, compute_commission_rates: Option<bool>, recv_window: Option<i64>) -> Result<serde_json::Value, Error<ApiV3SorOrderTestPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_side = side;
    let p_type = r#type;
    let p_quantity = quantity;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_time_in_force = time_in_force;
    let p_price = price;
    let p_new_client_order_id = new_client_order_id;
    let p_strategy_id = strategy_id;
    let p_strategy_type = strategy_type;
    let p_iceberg_qty = iceberg_qty;
    let p_new_order_resp_type = new_order_resp_type;
    let p_self_trade_prevention_mode = self_trade_prevention_mode;
    let p_compute_commission_rates = compute_commission_rates;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/api/v3/sor/order/test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("side", &p_side.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_time_in_force {
        req_builder = req_builder.query(&[("timeInForce", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("quantity", &p_quantity.to_string())]);
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_client_order_id {
        req_builder = req_builder.query(&[("newClientOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_id {
        req_builder = req_builder.query(&[("strategyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strategy_type {
        req_builder = req_builder.query(&[("strategyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_iceberg_qty {
        req_builder = req_builder.query(&[("icebergQty", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_new_order_resp_type {
        req_builder = req_builder.query(&[("newOrderRespType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_self_trade_prevention_mode {
        req_builder = req_builder.query(&[("selfTradePreventionMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_compute_commission_rates {
        req_builder = req_builder.query(&[("computeCommissionRates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV3SorOrderTestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

