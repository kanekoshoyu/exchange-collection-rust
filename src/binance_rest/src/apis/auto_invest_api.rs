/*
 * Binance Public Spot API
 *
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`sapi_v1_lending_auto_invest_all_asset_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestAllAssetGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_history_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestHistoryListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_index_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestIndexInfoGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_index_user_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestIndexUserSummaryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_one_off_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestOneOffPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_one_off_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestOneOffStatusGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_plan_add_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestPlanAddPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_plan_edit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestPlanEditPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_plan_edit_status_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestPlanEditStatusPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_plan_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestPlanIdGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_plan_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestPlanListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_rebalance_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestRebalanceHistoryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_redeem_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestRedeemHistoryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_redeem_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestRedeemPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_source_asset_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestSourceAssetListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_target_asset_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestTargetAssetListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_lending_auto_invest_target_asset_roi_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1LendingAutoInvestTargetAssetRoiListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}


/// Query all source assets and target assets  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_all_asset_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestAllAssetGet200Response, Error<SapiV1LendingAutoInvestAllAssetGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/all/asset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestAllAssetGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query subscription transaction history of a plan  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_history_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, plan_id: Option<i64>, start_time: Option<i64>, end_time: Option<i64>, target_asset: Option<f64>, plan_type: Option<&str>, size: Option<i32>, current: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1LendingAutoInvestHistoryListGet200ResponseInner>, Error<SapiV1LendingAutoInvestHistoryListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_plan_id = plan_id;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_target_asset = target_asset;
    let p_plan_type = plan_type;
    let p_size = size;
    let p_current = current;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/history/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_plan_id {
        req_builder = req_builder.query(&[("planId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_target_asset {
        req_builder = req_builder.query(&[("targetAsset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_plan_type {
        req_builder = req_builder.query(&[("planType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_current {
        req_builder = req_builder.query(&[("current", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestHistoryListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query index details  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_index_info_get(configuration: &configuration::Configuration, index_id: i64, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestIndexInfoGet200Response, Error<SapiV1LendingAutoInvestIndexInfoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/index/info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("indexId", &p_index_id.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestIndexInfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Details on users Index-Linked plan position details  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_index_user_summary_get(configuration: &configuration::Configuration, index_id: i64, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestIndexUserSummaryGet200Response, Error<SapiV1LendingAutoInvestIndexUserSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/index/user-summary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("indexId", &p_index_id.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestIndexUserSummaryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// One time transaction  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_one_off_post(configuration: &configuration::Configuration, source_type: &str, subscription_amount: f32, source_asset: &str, timestamp: i64, signature: &str, request_id: Option<&str>, flexible_allowed_to_use: Option<bool>, plan_id: Option<i64>, index_id: Option<i64>, details: Option<Vec<models::SapiV1LendingAutoInvestOneOffPostDetailsParameterInner>>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestOneOffPost200Response, Error<SapiV1LendingAutoInvestOneOffPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_source_type = source_type;
    let p_subscription_amount = subscription_amount;
    let p_source_asset = source_asset;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_request_id = request_id;
    let p_flexible_allowed_to_use = flexible_allowed_to_use;
    let p_plan_id = plan_id;
    let p_index_id = index_id;
    let p_details = details;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/one-off", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("sourceType", &p_source_type.to_string())]);
    if let Some(ref param_value) = p_request_id {
        req_builder = req_builder.query(&[("requestId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("subscriptionAmount", &p_subscription_amount.to_string())]);
    req_builder = req_builder.query(&[("sourceAsset", &p_source_asset.to_string())]);
    if let Some(ref param_value) = p_flexible_allowed_to_use {
        req_builder = req_builder.query(&[("flexibleAllowedToUse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_plan_id {
        req_builder = req_builder.query(&[("planId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_index_id {
        req_builder = req_builder.query(&[("indexId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_details {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("details".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("details", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestOneOffPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Transaction status for one-time transaction  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_one_off_status_get(configuration: &configuration::Configuration, transaction_id: i64, timestamp: i64, signature: &str, request_id: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestOneOffStatusGet200Response, Error<SapiV1LendingAutoInvestOneOffStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_transaction_id = transaction_id;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_request_id = request_id;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/one-off/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("transactionId", &p_transaction_id.to_string())]);
    if let Some(ref param_value) = p_request_id {
        req_builder = req_builder.query(&[("requestId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestOneOffStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Post an investment plan creation  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_plan_add_post(configuration: &configuration::Configuration, source_type: &str, plan_type: &str, subscription_amount: f32, subscription_cycle: &str, subscription_start_time: i32, source_asset: &str, details: Vec<models::SapiV1LendingAutoInvestPlanAddPostDetailsParameterInner>, timestamp: i64, signature: &str, request_id: Option<&str>, index_id: Option<i64>, subscription_start_day: Option<i32>, subscription_start_weekday: Option<&str>, flexible_allowed_to_use: Option<bool>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestPlanAddPost200Response, Error<SapiV1LendingAutoInvestPlanAddPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_source_type = source_type;
    let p_plan_type = plan_type;
    let p_subscription_amount = subscription_amount;
    let p_subscription_cycle = subscription_cycle;
    let p_subscription_start_time = subscription_start_time;
    let p_source_asset = source_asset;
    let p_details = details;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_request_id = request_id;
    let p_index_id = index_id;
    let p_subscription_start_day = subscription_start_day;
    let p_subscription_start_weekday = subscription_start_weekday;
    let p_flexible_allowed_to_use = flexible_allowed_to_use;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/plan/add", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("sourceType", &p_source_type.to_string())]);
    if let Some(ref param_value) = p_request_id {
        req_builder = req_builder.query(&[("requestId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("planType", &p_plan_type.to_string())]);
    if let Some(ref param_value) = p_index_id {
        req_builder = req_builder.query(&[("IndexId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("subscriptionAmount", &p_subscription_amount.to_string())]);
    req_builder = req_builder.query(&[("subscriptionCycle", &p_subscription_cycle.to_string())]);
    if let Some(ref param_value) = p_subscription_start_day {
        req_builder = req_builder.query(&[("subscriptionStartDay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_subscription_start_weekday {
        req_builder = req_builder.query(&[("subscriptionStartWeekday", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("subscriptionStartTime", &p_subscription_start_time.to_string())]);
    req_builder = req_builder.query(&[("sourceAsset", &p_source_asset.to_string())]);
    if let Some(ref param_value) = p_flexible_allowed_to_use {
        req_builder = req_builder.query(&[("flexibleAllowedToUse", &param_value.to_string())]);
    }
    req_builder = match "multi" {
        "multi" => req_builder.query(&p_details.into_iter().map(|p| ("details".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("details", &p_details.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestPlanAddPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Source Asset to be used for investment  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_plan_edit_post(configuration: &configuration::Configuration, plan_id: i32, subscription_amount: f32, subscription_cycle: &str, subscription_start_time: i32, source_asset: &str, timestamp: i64, signature: &str, subscription_start_day: Option<i32>, subscription_start_weekday: Option<&str>, flexible_allowed_to_use: Option<bool>, details: Option<Vec<models::SapiV1LendingAutoInvestPlanAddPostDetailsParameterInner>>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestPlanAddPost200Response, Error<SapiV1LendingAutoInvestPlanEditPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_plan_id = plan_id;
    let p_subscription_amount = subscription_amount;
    let p_subscription_cycle = subscription_cycle;
    let p_subscription_start_time = subscription_start_time;
    let p_source_asset = source_asset;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_subscription_start_day = subscription_start_day;
    let p_subscription_start_weekday = subscription_start_weekday;
    let p_flexible_allowed_to_use = flexible_allowed_to_use;
    let p_details = details;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/plan/edit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("planId", &p_plan_id.to_string())]);
    req_builder = req_builder.query(&[("subscriptionAmount", &p_subscription_amount.to_string())]);
    req_builder = req_builder.query(&[("subscriptionCycle", &p_subscription_cycle.to_string())]);
    if let Some(ref param_value) = p_subscription_start_day {
        req_builder = req_builder.query(&[("subscriptionStartDay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_subscription_start_weekday {
        req_builder = req_builder.query(&[("subscriptionStartWeekday", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("subscriptionStartTime", &p_subscription_start_time.to_string())]);
    req_builder = req_builder.query(&[("sourceAsset", &p_source_asset.to_string())]);
    if let Some(ref param_value) = p_flexible_allowed_to_use {
        req_builder = req_builder.query(&[("flexibleAllowedToUse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_details {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("details".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("details", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestPlanEditPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change Plan Status  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_plan_edit_status_post(configuration: &configuration::Configuration, plan_id: i32, status: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestPlanEditStatusPost200Response, Error<SapiV1LendingAutoInvestPlanEditStatusPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_plan_id = plan_id;
    let p_status = status;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/plan/edit-status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("planId", &p_plan_id.to_string())]);
    req_builder = req_builder.query(&[("status", &p_status.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestPlanEditStatusPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query holding details of the plan  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_plan_id_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, plan_id: Option<i64>, request_id: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestPlanIdGet200Response, Error<SapiV1LendingAutoInvestPlanIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_plan_id = plan_id;
    let p_request_id = request_id;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/plan/id", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_plan_id {
        req_builder = req_builder.query(&[("planId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_request_id {
        req_builder = req_builder.query(&[("requestId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestPlanIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query plan lists  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_plan_list_get(configuration: &configuration::Configuration, plan_type: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestPlanListGet200Response, Error<SapiV1LendingAutoInvestPlanListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_plan_type = plan_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/plan/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("planType", &p_plan_type.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestPlanListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the history of Index Linked Plan Redemption transactions  Max 30 day difference between startTime and endTime If no startTime and endTime, default to show past 30 day records  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_rebalance_history_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, current: Option<i32>, size: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1LendingAutoInvestRebalanceHistoryGet200ResponseInner>, Error<SapiV1LendingAutoInvestRebalanceHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_current = current;
    let p_size = size;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/rebalance/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_current {
        req_builder = req_builder.query(&[("current", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestRebalanceHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the history of Index Linked Plan Redemption transactions  Max 30 day difference between startTime and endTime If no startTime and endTime, default to show past 30 day records  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_redeem_history_get(configuration: &configuration::Configuration, request_id: i64, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, current: Option<i32>, asset: Option<&str>, size: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1LendingAutoInvestRedeemHistoryGet200ResponseInner>, Error<SapiV1LendingAutoInvestRedeemHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_id = request_id;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_current = current;
    let p_asset = asset;
    let p_size = size;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/redeem/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("requestId", &p_request_id.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_current {
        req_builder = req_builder.query(&[("current", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_asset {
        req_builder = req_builder.query(&[("asset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestRedeemHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// To redeem index-Linked plan holdings  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_redeem_post(configuration: &configuration::Configuration, index_id: i64, redemption_percentage: i32, timestamp: i64, signature: &str, request_id: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestRedeemPost200Response, Error<SapiV1LendingAutoInvestRedeemPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index_id = index_id;
    let p_redemption_percentage = redemption_percentage;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_request_id = request_id;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/redeem", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("indexId", &p_index_id.to_string())]);
    if let Some(ref param_value) = p_request_id {
        req_builder = req_builder.query(&[("requestId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("redemptionPercentage", &p_redemption_percentage.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestRedeemPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Source Asset to be used for investment  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_source_asset_list_get(configuration: &configuration::Configuration, usage_type: &str, timestamp: i64, signature: &str, target_asset: Option<&str>, index_id: Option<i64>, flexible_allowed_to_use: Option<bool>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestSourceAssetListGet200Response, Error<SapiV1LendingAutoInvestSourceAssetListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_usage_type = usage_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_target_asset = target_asset;
    let p_index_id = index_id;
    let p_flexible_allowed_to_use = flexible_allowed_to_use;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/source-asset/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_target_asset {
        req_builder = req_builder.query(&[("targetAsset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_index_id {
        req_builder = req_builder.query(&[("indexId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("usageType", &p_usage_type.to_string())]);
    if let Some(ref param_value) = p_flexible_allowed_to_use {
        req_builder = req_builder.query(&[("flexibleAllowedToUse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestSourceAssetListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_target_asset_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, target_asset: Option<&str>, size: Option<i32>, current: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV1LendingAutoInvestTargetAssetListGet200Response, Error<SapiV1LendingAutoInvestTargetAssetListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_target_asset = target_asset;
    let p_size = size;
    let p_current = current;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/target-asset/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_target_asset {
        req_builder = req_builder.query(&[("targetAsset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_current {
        req_builder = req_builder.query(&[("current", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestTargetAssetListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// ROI return list for target asset  Weight(IP): 1
pub async fn sapi_v1_lending_auto_invest_target_asset_roi_list_get(configuration: &configuration::Configuration, target_asset: &str, his_roi_type: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::SapiV1LendingAutoInvestTargetAssetRoiListGet200ResponseInner>, Error<SapiV1LendingAutoInvestTargetAssetRoiListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_target_asset = target_asset;
    let p_his_roi_type = his_roi_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/lending/auto-invest/target-asset/roi/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("targetAsset", &p_target_asset.to_string())]);
    req_builder = req_builder.query(&[("hisRoiType", &p_his_roi_type.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1LendingAutoInvestTargetAssetRoiListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

