/*
 * Binance Public Spot API
 *
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`sapi_v1_capital_deposit_sub_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1CapitalDepositSubAddressGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_capital_deposit_sub_hisrec_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1CapitalDepositSubHisrecGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_account_snapshot_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountAccountSnapshotGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_asset_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountAssetGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_deposit_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountDepositAddressGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_deposit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountDepositPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_fetch_future_asset_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountFetchFutureAssetGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountInfoGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_margin_asset_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountMarginAssetGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_query_trans_log_for_investor_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountQueryTransLogForInvestorGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_query_trans_log_for_trade_parent_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountQueryTransLogForTradeParentGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_query_trans_log_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountQueryTransLogGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_managed_subaccount_withdraw_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1ManagedSubaccountWithdrawPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_blvt_enable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountBlvtEnablePostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_eoptions_enable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountEoptionsEnablePostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_futures_account_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountFuturesAccountGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_futures_account_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountFuturesAccountSummaryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_futures_enable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountFuturesEnablePostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_futures_internal_transfer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountFuturesInternalTransferGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_futures_internal_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountFuturesInternalTransferPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_futures_position_risk_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountFuturesPositionRiskGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_futures_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountFuturesTransferPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_margin_account_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountMarginAccountGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_margin_account_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountMarginAccountSummaryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_margin_enable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountMarginEnablePostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_margin_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountMarginTransferPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_spot_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountSpotSummaryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountStatusGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_sub_account_api_ip_restriction_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountSubAccountApiIpRestrictionGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_sub_account_api_ip_restriction_ip_list_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountSubAccountApiIpRestrictionIpListDeleteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_sub_transfer_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountSubTransferHistoryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_transaction_statistics_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountTransactionStatisticsGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_transfer_sub_to_master_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountTransferSubToMasterPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_transfer_sub_to_sub_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountTransferSubToSubPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_transfer_sub_user_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountTransferSubUserHistoryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_universal_transfer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountUniversalTransferGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_universal_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountUniversalTransferPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v1_sub_account_virtual_sub_account_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV1SubAccountVirtualSubAccountPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v2_sub_account_futures_account_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV2SubAccountFuturesAccountGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v2_sub_account_futures_account_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV2SubAccountFuturesAccountSummaryGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v2_sub_account_futures_position_risk_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV2SubAccountFuturesPositionRiskGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v2_sub_account_sub_account_api_ip_restriction_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV2SubAccountSubAccountApiIpRestrictionPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v3_sub_account_assets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV3SubAccountAssetsGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sapi_v4_sub_account_assets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SapiV4SubAccountAssetsGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}


/// Fetch sub-account deposit address  Weight(IP): 1
pub async fn sapi_v1_capital_deposit_sub_address_get(configuration: &configuration::Configuration, email: &str, coin: &str, timestamp: i64, signature: &str, network: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1CapitalDepositSubAddressGet200Response, Error<SapiV1CapitalDepositSubAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_coin = coin;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_network = network;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/capital/deposit/subAddress", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_network {
        req_builder = req_builder.query(&[("network", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1CapitalDepositSubAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch sub-account deposit history  Weight(IP): 1
pub async fn sapi_v1_capital_deposit_sub_hisrec_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, coin: Option<&str>, status: Option<i32>, start_time: Option<i64>, end_time: Option<i64>, limit: Option<i64>, offset: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1CapitalDepositSubHisrecGet200ResponseInner>, Error<SapiV1CapitalDepositSubHisrecGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_coin = coin;
    let p_status = status;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;
    let p_offset = offset;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/capital/deposit/subHisrec", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1CapitalDepositSubHisrecGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - The query time period must be less then 30 days - Support query within the last one month only - If `startTime` and `endTime` not sent, return records of the last 7 days by default  Weight(IP): 2400
pub async fn sapi_v1_managed_subaccount_account_snapshot_get(configuration: &configuration::Configuration, email: &str, r#type: &str, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountAccountSnapshotGet200Response, Error<SapiV1ManagedSubaccountAccountSnapshotGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_type = r#type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/accountSnapshot", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountAccountSnapshotGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_managed_subaccount_asset_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::SapiV1ManagedSubaccountAssetGet200ResponseInner>, Error<SapiV1ManagedSubaccountAssetGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/asset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountAssetGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get investor's managed sub-account deposit address  Weight(UID): 1
pub async fn sapi_v1_managed_subaccount_deposit_address_get(configuration: &configuration::Configuration, email: &str, coin: &str, timestamp: i64, signature: &str, network: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountDepositAddressGet200Response, Error<SapiV1ManagedSubaccountDepositAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_coin = coin;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_network = network;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/deposit/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_network {
        req_builder = req_builder.query(&[("network", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountDepositAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_managed_subaccount_deposit_post(configuration: &configuration::Configuration, to_email: &str, asset: &str, amount: f64, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountDepositPost200Response, Error<SapiV1ManagedSubaccountDepositPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_to_email = to_email;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/deposit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("toEmail", &p_to_email.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountDepositPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Investor can use this api to query managed sub account futures asset details
pub async fn sapi_v1_managed_subaccount_fetch_future_asset_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountFetchFutureAssetGet200Response, Error<SapiV1ManagedSubaccountFetchFutureAssetGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/fetch-future-asset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountFetchFutureAssetGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get investor's managed sub-account list.  Weight(UID): 60
pub async fn sapi_v1_managed_subaccount_info_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, page: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountInfoGet200Response, Error<SapiV1ManagedSubaccountInfoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountInfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Investor can use this api to query managed sub account margin asset details
pub async fn sapi_v1_managed_subaccount_margin_asset_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountMarginAssetGet200Response, Error<SapiV1ManagedSubaccountMarginAssetGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/marginAsset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountMarginAssetGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Investor can use this api to query managed sub account transfer log. This endpoint is available for investor of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.  Weight(IP): 1
pub async fn sapi_v1_managed_subaccount_query_trans_log_for_investor_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, page: Option<i32>, limit: Option<i32>, transfers: Option<&str>, transfer_function_account_type: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountQueryTransLogForInvestorGet200Response, Error<SapiV1ManagedSubaccountQueryTransLogForInvestorGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;
    let p_transfers = transfers;
    let p_transfer_function_account_type = transfer_function_account_type;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/queryTransLogForInvestor", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transfers {
        req_builder = req_builder.query(&[("transfers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transfer_function_account_type {
        req_builder = req_builder.query(&[("transferFunctionAccountType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountQueryTransLogForInvestorGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Trading team can use this api to query managed sub account transfer log. This endpoint is available for trading team of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team  Weight(IP): 60
pub async fn sapi_v1_managed_subaccount_query_trans_log_for_trade_parent_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, page: Option<i32>, limit: Option<i32>, transfers: Option<&str>, transfer_function_account_type: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountQueryTransLogForInvestorGet200Response, Error<SapiV1ManagedSubaccountQueryTransLogForTradeParentGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;
    let p_transfers = transfers;
    let p_transfer_function_account_type = transfer_function_account_type;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/queryTransLogForTradeParent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transfers {
        req_builder = req_builder.query(&[("transfers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transfer_function_account_type {
        req_builder = req_builder.query(&[("transferFunctionAccountType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountQueryTransLogForTradeParentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Managed Sub Account Transfer Log (For Trading Team Sub Account)  Weight(UID): 60
pub async fn sapi_v1_managed_subaccount_query_trans_log_get(configuration: &configuration::Configuration, transfers: &str, transfer_function_account_type: &str, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, page: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountQueryTransLogGet200Response, Error<SapiV1ManagedSubaccountQueryTransLogGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_transfers = transfers;
    let p_transfer_function_account_type = transfer_function_account_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/query-trans-log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("transfers", &p_transfers.to_string())]);
    req_builder = req_builder.query(&[("transferFunctionAccountType", &p_transfer_function_account_type.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountQueryTransLogGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_managed_subaccount_withdraw_post(configuration: &configuration::Configuration, from_email: &str, asset: &str, amount: f64, timestamp: i64, signature: &str, transfer_date: Option<i64>, recv_window: Option<i64>) -> Result<models::SapiV1ManagedSubaccountDepositPost200Response, Error<SapiV1ManagedSubaccountWithdrawPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_email = from_email;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_transfer_date = transfer_date;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/managed-subaccount/withdraw", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("fromEmail", &p_from_email.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_transfer_date {
        req_builder = req_builder.query(&[("transferDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1ManagedSubaccountWithdrawPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_blvt_enable_post(configuration: &configuration::Configuration, email: &str, enable_blvt: bool, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountBlvtEnablePost200Response, Error<SapiV1SubAccountBlvtEnablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_enable_blvt = enable_blvt;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/blvt/enable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("enableBlvt", &p_enable_blvt.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountBlvtEnablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Options for Sub-account (For Master Account).  Weight(IP): 1
pub async fn sapi_v1_sub_account_eoptions_enable_post(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountEoptionsEnablePost200Response, Error<SapiV1SubAccountEoptionsEnablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/eoptions/enable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountEoptionsEnablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 10
pub async fn sapi_v1_sub_account_futures_account_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesAccountGet200Response, Error<SapiV1SubAccountFuturesAccountGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/futures/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountFuturesAccountGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_futures_account_summary_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesAccountSummaryGet200Response, Error<SapiV1SubAccountFuturesAccountSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/futures/accountSummary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountFuturesAccountSummaryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_futures_enable_post(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesEnablePost200Response, Error<SapiV1SubAccountFuturesEnablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/futures/enable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountFuturesEnablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_futures_internal_transfer_get(configuration: &configuration::Configuration, email: &str, futures_type: i32, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, page: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesInternalTransferGet200Response, Error<SapiV1SubAccountFuturesInternalTransferGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_futures_type = futures_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/futures/internalTransfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("futuresType", &p_futures_type.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountFuturesInternalTransferGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - Master account can transfer max 2000 times a minute  Weight(IP): 1
pub async fn sapi_v1_sub_account_futures_internal_transfer_post(configuration: &configuration::Configuration, from_email: &str, to_email: &str, futures_type: i32, asset: &str, amount: f64, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesInternalTransferPost200Response, Error<SapiV1SubAccountFuturesInternalTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_email = from_email;
    let p_to_email = to_email;
    let p_futures_type = futures_type;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/futures/internalTransfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("fromEmail", &p_from_email.to_string())]);
    req_builder = req_builder.query(&[("toEmail", &p_to_email.to_string())]);
    req_builder = req_builder.query(&[("futuresType", &p_futures_type.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountFuturesInternalTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 10
pub async fn sapi_v1_sub_account_futures_position_risk_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::SapiV1SubAccountFuturesPositionRiskGet200ResponseInner>, Error<SapiV1SubAccountFuturesPositionRiskGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/futures/positionRisk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountFuturesPositionRiskGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_futures_transfer_post(configuration: &configuration::Configuration, email: &str, asset: &str, amount: f64, r#type: i32, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesTransferPost200Response, Error<SapiV1SubAccountFuturesTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_asset = asset;
    let p_amount = amount;
    let p_type = r#type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/futures/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountFuturesTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, email: Option<&str>, is_freeze: Option<&str>, page: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountListGet200Response, Error<SapiV1SubAccountListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_email = email;
    let p_is_freeze = is_freeze;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_freeze {
        req_builder = req_builder.query(&[("isFreeze", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 10
pub async fn sapi_v1_sub_account_margin_account_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountMarginAccountGet200Response, Error<SapiV1SubAccountMarginAccountGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/margin/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountMarginAccountGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 10
pub async fn sapi_v1_sub_account_margin_account_summary_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountMarginAccountSummaryGet200Response, Error<SapiV1SubAccountMarginAccountSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/margin/accountSummary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountMarginAccountSummaryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_margin_enable_post(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountMarginEnablePost200Response, Error<SapiV1SubAccountMarginEnablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/margin/enable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountMarginEnablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_margin_transfer_post(configuration: &configuration::Configuration, email: &str, asset: &str, amount: f64, r#type: i32, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesTransferPost200Response, Error<SapiV1SubAccountMarginTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_asset = asset;
    let p_amount = amount;
    let p_type = r#type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/margin/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountMarginTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get BTC valued asset summary of subaccounts.  Weight(IP): 1
pub async fn sapi_v1_sub_account_spot_summary_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, email: Option<&str>, page: Option<i32>, size: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountSpotSummaryGet200Response, Error<SapiV1SubAccountSpotSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_email = email;
    let p_page = page;
    let p_size = size;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/spotSummary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountSpotSummaryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - If no `email` sent, all sub-accounts' information will be returned.  Weight(IP): 10
pub async fn sapi_v1_sub_account_status_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, email: Option<&str>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1SubAccountStatusGet200ResponseInner>, Error<SapiV1SubAccountStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_email = email;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(UID): 3000
pub async fn sapi_v1_sub_account_sub_account_api_ip_restriction_get(configuration: &configuration::Configuration, email: &str, sub_account_api_key: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountSubAccountApiIpRestrictionGet200Response, Error<SapiV1SubAccountSubAccountApiIpRestrictionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_sub_account_api_key = sub_account_api_key;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/subAccountApi/ipRestriction", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("subAccountApiKey", &p_sub_account_api_key.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountSubAccountApiIpRestrictionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(UID): 3000
pub async fn sapi_v1_sub_account_sub_account_api_ip_restriction_ip_list_delete(configuration: &configuration::Configuration, email: &str, sub_account_api_key: &str, timestamp: i64, signature: &str, ip_address: Option<&str>, third_party_name: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountSubAccountApiIpRestrictionIpListDelete200Response, Error<SapiV1SubAccountSubAccountApiIpRestrictionIpListDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_sub_account_api_key = sub_account_api_key;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_ip_address = ip_address;
    let p_third_party_name = third_party_name;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/subAccountApi/ipRestriction/ipList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("subAccountApiKey", &p_sub_account_api_key.to_string())]);
    if let Some(ref param_value) = p_ip_address {
        req_builder = req_builder.query(&[("ipAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_third_party_name {
        req_builder = req_builder.query(&[("thirdPartyName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountSubAccountApiIpRestrictionIpListDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - fromEmail and toEmail cannot be sent at the same time. - Return fromEmail equal master account email by default.  Weight(IP): 1
pub async fn sapi_v1_sub_account_sub_transfer_history_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, from_email: Option<&str>, to_email: Option<&str>, start_time: Option<i64>, end_time: Option<i64>, page: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1SubAccountSubTransferHistoryGet200ResponseInner>, Error<SapiV1SubAccountSubTransferHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_from_email = from_email;
    let p_to_email = to_email;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/sub/transfer/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_from_email {
        req_builder = req_builder.query(&[("fromEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_email {
        req_builder = req_builder.query(&[("toEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountSubTransferHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Sub-account Transaction statistics (For Master Account).  Weight(UID): 60
pub async fn sapi_v1_sub_account_transaction_statistics_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountTransactionStatisticsGet200Response, Error<SapiV1SubAccountTransactionStatisticsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/transaction-statistics", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountTransactionStatisticsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_transfer_sub_to_master_post(configuration: &configuration::Configuration, asset: &str, amount: f64, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesTransferPost200Response, Error<SapiV1SubAccountTransferSubToMasterPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/transfer/subToMaster", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountTransferSubToMasterPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v1_sub_account_transfer_sub_to_sub_post(configuration: &configuration::Configuration, to_email: &str, asset: &str, amount: f64, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountFuturesTransferPost200Response, Error<SapiV1SubAccountTransferSubToSubPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_to_email = to_email;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/transfer/subToSub", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("toEmail", &p_to_email.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountTransferSubToSubPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - If `type` is not sent, the records of type 2: transfer out will be returned by default. - If `startTime` and `endTime` are not sent, the recent 30-day data will be returned.  Weight(IP): 1
pub async fn sapi_v1_sub_account_transfer_sub_user_history_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, asset: Option<&str>, r#type: Option<i32>, start_time: Option<i64>, end_time: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1SubAccountTransferSubUserHistoryGet200ResponseInner>, Error<SapiV1SubAccountTransferSubUserHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_asset = asset;
    let p_type = r#type;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/transfer/subUserHistory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_asset {
        req_builder = req_builder.query(&[("asset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountTransferSubUserHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - `fromEmail` and `toEmail` cannot be sent at the same time. - Return `fromEmail` equal master account email by default. - The query time period must be less then 30 days. - If startTime and endTime not sent, return records of the last 30 days by default.  Weight(IP): 1
pub async fn sapi_v1_sub_account_universal_transfer_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, from_email: Option<&str>, to_email: Option<&str>, client_tran_id: Option<&str>, start_time: Option<i64>, end_time: Option<i64>, page: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::SapiV1SubAccountUniversalTransferGet200ResponseInner>, Error<SapiV1SubAccountUniversalTransferGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_from_email = from_email;
    let p_to_email = to_email;
    let p_client_tran_id = client_tran_id;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/universalTransfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_from_email {
        req_builder = req_builder.query(&[("fromEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_email {
        req_builder = req_builder.query(&[("toEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_tran_id {
        req_builder = req_builder.query(&[("clientTranId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountUniversalTransferGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - You need to enable \"internal transfer\" option for the api key which requests this endpoint. - Transfer from master account by default if fromEmail is not sent. - Transfer to master account by default if toEmail is not sent. - Supported transfer scenarios:   - Master account SPOT transfer to sub-account SPOT,USDT_FUTURE,COIN_FUTURE,MARGIN(Cross),ISOLATED_MARGIN   - Sub-account SPOT,USDT_FUTURE,COIN_FUTURE,MARGIN(Cross),ISOLATED_MARGIN transfer to master account SPOT   - Transfer between two sub-account SPOT accounts  Weight(IP): 1
pub async fn sapi_v1_sub_account_universal_transfer_post(configuration: &configuration::Configuration, from_account_type: &str, to_account_type: &str, asset: &str, amount: f64, timestamp: i64, signature: &str, from_email: Option<&str>, to_email: Option<&str>, client_tran_id: Option<&str>, symbol: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountUniversalTransferPost200Response, Error<SapiV1SubAccountUniversalTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_account_type = from_account_type;
    let p_to_account_type = to_account_type;
    let p_asset = asset;
    let p_amount = amount;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_from_email = from_email;
    let p_to_email = to_email;
    let p_client_tran_id = client_tran_id;
    let p_symbol = symbol;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/universalTransfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_from_email {
        req_builder = req_builder.query(&[("fromEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_email {
        req_builder = req_builder.query(&[("toEmail", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("fromAccountType", &p_from_account_type.to_string())]);
    req_builder = req_builder.query(&[("toAccountType", &p_to_account_type.to_string())]);
    if let Some(ref param_value) = p_client_tran_id {
        req_builder = req_builder.query(&[("clientTranId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountUniversalTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// - This request will generate a virtual sub account under your master account. - You need to enable \"trade\" option for the api key which requests this endpoint.  Weight(IP): 1
pub async fn sapi_v1_sub_account_virtual_sub_account_post(configuration: &configuration::Configuration, sub_account_string: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV1SubAccountVirtualSubAccountPost200Response, Error<SapiV1SubAccountVirtualSubAccountPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_account_string = sub_account_string;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v1/sub-account/virtualSubAccount", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("subAccountString", &p_sub_account_string.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV1SubAccountVirtualSubAccountPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v2_sub_account_futures_account_get(configuration: &configuration::Configuration, email: &str, futures_type: i32, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV2SubAccountFuturesAccountGet200Response, Error<SapiV2SubAccountFuturesAccountGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_futures_type = futures_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v2/sub-account/futures/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("futuresType", &p_futures_type.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV2SubAccountFuturesAccountGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 10
pub async fn sapi_v2_sub_account_futures_account_summary_get(configuration: &configuration::Configuration, futures_type: i32, timestamp: i64, signature: &str, page: Option<i32>, limit: Option<i32>, recv_window: Option<i64>) -> Result<models::SapiV2SubAccountFuturesAccountSummaryGet200Response, Error<SapiV2SubAccountFuturesAccountSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_futures_type = futures_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_page = page;
    let p_limit = limit;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v2/sub-account/futures/accountSummary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("futuresType", &p_futures_type.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV2SubAccountFuturesAccountSummaryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Weight(IP): 1
pub async fn sapi_v2_sub_account_futures_position_risk_get(configuration: &configuration::Configuration, email: &str, futures_type: i32, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV2SubAccountFuturesPositionRiskGet200Response, Error<SapiV2SubAccountFuturesPositionRiskGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_futures_type = futures_type;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v2/sub-account/futures/positionRisk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("futuresType", &p_futures_type.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV2SubAccountFuturesPositionRiskGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update IP Restriction for Sub-Account API key  Weight(UID): 3000
pub async fn sapi_v2_sub_account_sub_account_api_ip_restriction_post(configuration: &configuration::Configuration, email: &str, sub_account_api_key: &str, status: &str, timestamp: i64, signature: &str, third_party_name: Option<&str>, recv_window: Option<i64>) -> Result<models::SapiV2SubAccountSubAccountApiIpRestrictionPost200Response, Error<SapiV2SubAccountSubAccountApiIpRestrictionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_sub_account_api_key = sub_account_api_key;
    let p_status = status;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_third_party_name = third_party_name;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v2/sub-account/subAccountApi/ipRestriction", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    req_builder = req_builder.query(&[("subAccountApiKey", &p_sub_account_api_key.to_string())]);
    req_builder = req_builder.query(&[("status", &p_status.to_string())]);
    if let Some(ref param_value) = p_third_party_name {
        req_builder = req_builder.query(&[("thirdPartyName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV2SubAccountSubAccountApiIpRestrictionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch sub-account assets  Weight(IP): 1
pub async fn sapi_v3_sub_account_assets_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV3SubAccountAssetsGet200Response, Error<SapiV3SubAccountAssetsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v3/sub-account/assets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV3SubAccountAssetsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch sub-account assets  Weight(UID): 60
pub async fn sapi_v4_sub_account_assets_get(configuration: &configuration::Configuration, email: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::SapiV4SubAccountAssetsGet200Response, Error<SapiV4SubAccountAssetsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email = email;
    let p_timestamp = timestamp;
    let p_signature = signature;
    let p_recv_window = recv_window;

    let uri_str = format!("{}/sapi/v4/sub-account/assets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &p_email.to_string())]);
    if let Some(ref param_value) = p_recv_window {
        req_builder = req_builder.query(&[("recvWindow", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("timestamp", &p_timestamp.to_string())]);
    req_builder = req_builder.query(&[("signature", &p_signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SapiV4SubAccountAssetsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

