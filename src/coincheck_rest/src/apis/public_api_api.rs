/*
 * Coincheck Crypto Exchange
 *
 * Welcome to Coincheck API document! 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_exchange_orders_rate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeOrdersRateGetError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_exchange_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeStatusGetError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_order_books_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiOrderBooksGetError {
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_rate_pair_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiRatePairGetError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_ticker_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTickerGetError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTradesGetError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// Retrieve the calculated rate, price, or amount for a specified order.
pub async fn api_exchange_orders_rate_get(configuration: &configuration::Configuration, order_type: &str, pair: &str, amount: Option<f64>, price: Option<f64>) -> Result<models::OrderRateResponse, Error<ApiExchangeOrdersRateGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_type = order_type;
    let p_pair = pair;
    let p_amount = amount;
    let p_price = price;

    let uri_str = format!("{}/api/exchange/orders/rate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("order_type", &p_order_type.to_string())]);
    req_builder = req_builder.query(&[("pair", &p_pair.to_string())]);
    if let Some(ref param_value) = p_amount {
        req_builder = req_builder.query(&[("amount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeOrdersRateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the status of the exchange for all tradable pairs or a specific pair.
pub async fn api_exchange_status_get(configuration: &configuration::Configuration, pair: Option<&str>) -> Result<models::ApiExchangeStatusGet200Response, Error<ApiExchangeStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pair = pair;

    let uri_str = format!("{}/api/exchange_status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_pair {
        req_builder = req_builder.query(&[("pair", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current order book details including asks and bids.
pub async fn api_order_books_get(configuration: &configuration::Configuration, ) -> Result<models::OrderBookResponse, Error<ApiOrderBooksGetError>> {

    let uri_str = format!("{}/api/order_books", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiOrderBooksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the standard rate for a specified currency pair.
pub async fn api_rate_pair_get(configuration: &configuration::Configuration, pair: &str) -> Result<models::StandardRateResponse, Error<ApiRatePairGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pair = pair;

    let uri_str = format!("{}/api/rate/{pair}", configuration.base_path, pair=crate::apis::urlencode(p_pair));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiRatePairGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the latest ticker data for a specified currency pair.
pub async fn api_ticker_get(configuration: &configuration::Configuration, pair: &str) -> Result<models::Tickers, Error<ApiTickerGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pair = pair;

    let uri_str = format!("{}/api/ticker", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("pair", &p_pair.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiTickerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the latest trades data for a specified currency pair.
pub async fn api_trades_get(configuration: &configuration::Configuration, pair: &str) -> Result<models::TradesResponse, Error<ApiTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pair = pair;

    let uri_str = format!("{}/api/trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("pair", &p_pair.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

