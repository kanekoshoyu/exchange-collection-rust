/*
 * Coincheck Crypto Exchange
 *
 * Welcome to Coincheck API document! 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_accounts_balance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiAccountsBalanceGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiAccountsGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_bank_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiBankAccountsGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_bank_accounts_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiBankAccountsIdDeleteError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_bank_accounts_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiBankAccountsPostError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_deposit_money_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDepositMoneyGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_exchange_orders_cancel_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeOrdersCancelStatusGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_exchange_orders_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeOrdersIdDeleteError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_exchange_orders_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeOrdersIdGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_exchange_orders_opens_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeOrdersOpensGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_exchange_orders_transactions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeOrdersTransactionsGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_exchange_orders_transactions_pagination_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiExchangeOrdersTransactionsPaginationGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_send_money_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiSendMoneyGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_send_money_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiSendMoneyPostError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_withdraws_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWithdrawsGetError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_withdraws_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWithdrawsIdDeleteError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_withdraws_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWithdrawsPostError {
    Status429(models::RateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`place_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlaceOrderError {
    Status400(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// Fetch your account balance, including reserved amounts and lending details.
pub async fn api_accounts_balance_get(configuration: &configuration::Configuration, ) -> Result<models::Balance, Error<ApiAccountsBalanceGetError>> {

    let uri_str = format!("{}/api/accounts/balance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiAccountsBalanceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch detailed information about the account, including identity status, registered email, bitcoin address, and fees.
pub async fn api_accounts_get(configuration: &configuration::Configuration, ) -> Result<models::Account, Error<ApiAccountsGetError>> {

    let uri_str = format!("{}/api/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiAccountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the list of bank accounts you have registered for withdrawal.
pub async fn api_bank_accounts_get(configuration: &configuration::Configuration, ) -> Result<models::ApiBankAccountsGet200Response, Error<ApiBankAccountsGetError>> {

    let uri_str = format!("{}/api/bank_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiBankAccountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a bank account using its ID.
pub async fn api_bank_accounts_id_delete(configuration: &configuration::Configuration, id: i32) -> Result<models::ApiBankAccountsIdDelete200Response, Error<ApiBankAccountsIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/bank_accounts/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiBankAccountsIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Registers a bank account for withdrawal.
pub async fn api_bank_accounts_post(configuration: &configuration::Configuration, bank_request: models::BankRequest) -> Result<models::BankResponse, Error<ApiBankAccountsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_bank_request = bank_request;

    let uri_str = format!("{}/api/bank_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    req_builder = req_builder.json(&p_bank_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiBankAccountsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the history of BTC deposit transactions.
pub async fn api_deposit_money_get(configuration: &configuration::Configuration, currency: &str) -> Result<models::ApiDepositMoneyGet200Response, Error<ApiDepositMoneyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_currency = currency;

    let uri_str = format!("{}/api/deposit_money", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("currency", &p_currency.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiDepositMoneyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Refer to the cancellation processing status of an order by specifying its ID.
pub async fn api_exchange_orders_cancel_status_get(configuration: &configuration::Configuration, id: &str) -> Result<models::OrderStatus, Error<ApiExchangeOrdersCancelStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/exchange/orders/cancel_status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeOrdersCancelStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an order by specifying the order ID (either new or unsettled).
pub async fn api_exchange_orders_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<models::OrderDeletion, Error<ApiExchangeOrdersIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/exchange/orders/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeOrdersIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch details of a specific order using its ID.
pub async fn api_exchange_orders_id_get(configuration: &configuration::Configuration, id: &str) -> Result<models::OrderDetails, Error<ApiExchangeOrdersIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/exchange/orders/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeOrdersIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a list of all unsettled orders.
pub async fn api_exchange_orders_opens_get(configuration: &configuration::Configuration, ) -> Result<models::OpenOrders, Error<ApiExchangeOrdersOpensGetError>> {

    let uri_str = format!("{}/api/exchange/orders/opens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeOrdersOpensGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch your transaction history.
pub async fn api_exchange_orders_transactions_get(configuration: &configuration::Configuration, ) -> Result<models::Transactions, Error<ApiExchangeOrdersTransactionsGetError>> {

    let uri_str = format!("{}/api/exchange/orders/transactions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeOrdersTransactionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch your transaction history with pagination support.
pub async fn api_exchange_orders_transactions_pagination_get(configuration: &configuration::Configuration, limit: Option<i32>, order: Option<&str>, starting_after: Option<&str>, ending_before: Option<&str>) -> Result<models::TransactionPagination, Error<ApiExchangeOrdersTransactionsPaginationGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_order = order;
    let p_starting_after = starting_after;
    let p_ending_before = ending_before;

    let uri_str = format!("{}/api/exchange/orders/transactions_pagination", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_starting_after {
        req_builder = req_builder.query(&[("starting_after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ending_before {
        req_builder = req_builder.query(&[("ending_before", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiExchangeOrdersTransactionsPaginationGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the history of BTC sending transactions.
pub async fn api_send_money_get(configuration: &configuration::Configuration, currency: &str) -> Result<models::ApiSendMoneyGet200Response, Error<ApiSendMoneyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_currency = currency;

    let uri_str = format!("{}/api/send_money", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("currency", &p_currency.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiSendMoneyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send cryptocurrency to a specified address with a purpose and detailed information.
pub async fn api_send_money_post(configuration: &configuration::Configuration, money_transfer_request: models::MoneyTransferRequest) -> Result<models::MoneyTransferResponse, Error<ApiSendMoneyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_money_transfer_request = money_transfer_request;

    let uri_str = format!("{}/api/send_money", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    req_builder = req_builder.json(&p_money_transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiSendMoneyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the history of Japanese YEN withdrawal requests.
pub async fn api_withdraws_get(configuration: &configuration::Configuration, limit: Option<i32>, order: Option<&str>, starting_after: Option<&str>, ending_before: Option<&str>) -> Result<models::ApiWithdrawsGet200Response, Error<ApiWithdrawsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_order = order;
    let p_starting_after = starting_after;
    let p_ending_before = ending_before;

    let uri_str = format!("{}/api/withdraws", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_starting_after {
        req_builder = req_builder.query(&[("starting_after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ending_before {
        req_builder = req_builder.query(&[("ending_before", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiWithdrawsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel a withdrawal request with a pending status.
pub async fn api_withdraws_id_delete(configuration: &configuration::Configuration, id: i32) -> Result<models::ApiBankAccountsIdDelete200Response, Error<ApiWithdrawsIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/api/withdraws/{id}", configuration.base_path, id=p_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiWithdrawsIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request a Japanese Yen withdrawal.
pub async fn api_withdraws_post(configuration: &configuration::Configuration, withdraw_request: models::WithdrawRequest) -> Result<models::ApiWithdrawsPost200Response, Error<ApiWithdrawsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdraw_request = withdraw_request;

    let uri_str = format!("{}/api/withdraws", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    req_builder = req_builder.json(&p_withdraw_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiWithdrawsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Publish a new order (buy/sell) to the exchange. You can place limit, spot, or market orders.
pub async fn place_order(configuration: &configuration::Configuration, order_request: models::OrderRequest) -> Result<models::OrderResponse, Error<PlaceOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_request = order_request;

    let uri_str = format!("{}/api/exchange/orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    req_builder = req_builder.json(&p_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PlaceOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

