/*
 * Bitget API
 *
 * Welcome to Bitget Developer document! 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`mix_order_batch_cancel_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderBatchCancelOrdersPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_batch_place_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderBatchPlaceOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_cancel_all_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderCancelAllOrdersPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_cancel_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderCancelOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_click_backhand_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderClickBackhandPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_close_positions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderClosePositionsPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_detail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderDetailGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_fill_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderFillHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_fills_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderFillsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_modify_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderModifyOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_orders_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderOrdersHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_orders_pending_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderOrdersPendingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mix_order_place_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MixOrderPlaceOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Speed limit is 10 times/s for average users. Frequency limit imposed according to user ID.Order cancelling interface, can be used to cancel by product type and trading pair.
pub async fn mix_order_batch_cancel_orders_post(configuration: &configuration::Configuration, cancel_batch_order_request: Option<models::CancelBatchOrderRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<MixOrderBatchCancelOrdersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cancel_batch_order_request = cancel_batch_order_request;

    let uri_str = format!("{}/mix/order/batch-cancel-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_cancel_batch_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderBatchCancelOrdersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit: 5 requests/second/UID<br>Rate limit: 1 request/second/UID for copy trading traders<br>Supports TP/SL feature. If the current underlying asset does not exist in the position, it is intended to preset the TP/SL. If the current underlying exists in the position, it is intended to modify the TP/SL<br>Ignore the tradeSide parameter when position mode is in one-way-mode
pub async fn mix_order_batch_place_order_post(configuration: &configuration::Configuration, batch_orders_request: Option<models::BatchOrdersRequest>) -> Result<models::SpotTradeBatchOrdersPost200Response, Error<MixOrderBatchPlaceOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_batch_orders_request = batch_orders_request;

    let uri_str = format!("{}/mix/order/batch-place-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_batch_orders_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderBatchPlaceOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s
pub async fn mix_order_cancel_all_orders_post(configuration: &configuration::Configuration, cancel_all_order_request: Option<models::CancelAllOrderRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<MixOrderCancelAllOrdersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cancel_all_order_request = cancel_all_order_request;

    let uri_str = format!("{}/mix/order/cancel-all-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_cancel_all_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderCancelAllOrdersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s
pub async fn mix_order_cancel_order_post(configuration: &configuration::Configuration, cancel_order_request: Option<models::CancelOrderRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<MixOrderCancelOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cancel_order_request = cancel_order_request;

    let uri_str = format!("{}/mix/order/cancel-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_cancel_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderCancelOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn mix_order_click_backhand_post(configuration: &configuration::Configuration, reversal_request: Option<models::ReversalRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<MixOrderClickBackhandPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_reversal_request = reversal_request;

    let uri_str = format!("{}/mix/order/click-backhand", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_reversal_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderClickBackhandPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Speed limit is 1 times/s
pub async fn mix_order_close_positions_post(configuration: &configuration::Configuration, flash_request: Option<models::FlashRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<MixOrderClosePositionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_flash_request = flash_request;

    let uri_str = format!("{}/mix/order/close-positions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_flash_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderClosePositionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Speed limit is 1 times/s
pub async fn mix_order_detail_get(configuration: &configuration::Configuration, product_type: &str, symbol: Option<&str>, order_id: Option<&str>, client_oid: Option<&str>) -> Result<models::MixOrderDetailGet200Response, Error<MixOrderDetailGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_type = product_type;
    let p_symbol = symbol;
    let p_order_id = order_id;
    let p_client_oid = client_oid;

    let uri_str = format!("{}/mix/order/detail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("productType", &p_product_type.to_string())]);
    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_oid {
        req_builder = req_builder.query(&[("clientOid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderDetailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Speed limit is 10 times/s for average users. Frequency limit imposed according to user ID
pub async fn mix_order_fill_history_get(configuration: &configuration::Configuration, product_type: &str, order_id: Option<&str>, symbol: Option<&str>, id_less_than: Option<&str>, start_time: Option<String>, end_time: Option<String>, limit: Option<i32>) -> Result<models::MixOrderFillsGet200Response, Error<MixOrderFillHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_type = product_type;
    let p_order_id = order_id;
    let p_symbol = symbol;
    let p_id_less_than = id_less_than;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;

    let uri_str = format!("{}/mix/order/fill-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("productType", &p_product_type.to_string())]);
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderFillHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Speed limit is 10 times/s for average users. Frequency limit imposed according to user ID
pub async fn mix_order_fills_get(configuration: &configuration::Configuration, product_type: &str, order_id: Option<&str>, symbol: Option<&str>, id_less_than: Option<&str>, start_time: Option<String>, end_time: Option<String>, limit: Option<i32>) -> Result<models::MixOrderFillsGet200Response, Error<MixOrderFillsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_type = product_type;
    let p_order_id = order_id;
    let p_symbol = symbol;
    let p_id_less_than = id_less_than;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;

    let uri_str = format!("{}/mix/order/fills", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("productType", &p_product_type.to_string())]);
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderFillsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Speed limit is 10 times/s for average users. Frequency limit imposed according to user ID<br>Interface for order modification, used to modify an pending order, such as its TP/SL and/or price/size.<br>Modifying size and price will cancel the old order; then create a new order asynchronously, modify the preset TPSL will not cancel the old order.<br>Modifying size and price, please pass in both, not just one of them<br>Modify the order price, size and preset TPSL according to orderId or clientOId<br>It is only allowed to modify the new status limit order. If the size, price and TPSL all is set in the request, then the TPSL will not work<br>Modify the limit order price and size, please be sure to provide newClientOid, because the orderId of the new order cannot be returned synchronously, so you need to use newClientOid to help you query order information<br>Modifying the order size needs to meet the minimum order quantity<br>If you only modify the TPSL, please do not pass price and size. If you only pass one of TP or SL, the other one will be cancelled
pub async fn mix_order_modify_order_post(configuration: &configuration::Configuration, modify_orders_request: Option<models::ModifyOrdersRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<MixOrderModifyOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_modify_orders_request = modify_orders_request;

    let uri_str = format!("{}/mix/order/modify-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_modify_orders_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderModifyOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit: 10 req/sec/UID.Get history order(It only supports to get the data within 90days. The older data can be downloaded from web)
pub async fn mix_order_orders_history_get(configuration: &configuration::Configuration, product_type: &str, order_id: Option<&str>, client_oid: Option<&str>, symbol: Option<&str>, id_less_than: Option<&str>, order_source: Option<&str>, start_time: Option<String>, end_time: Option<String>, limit: Option<i32>) -> Result<models::MixOrderOrdersPendingGet200Response, Error<MixOrderOrdersHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_type = product_type;
    let p_order_id = order_id;
    let p_client_oid = client_oid;
    let p_symbol = symbol;
    let p_id_less_than = id_less_than;
    let p_order_source = order_source;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;

    let uri_str = format!("{}/mix/order/orders-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_oid {
        req_builder = req_builder.query(&[("clientOid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("productType", &p_product_type.to_string())]);
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_source {
        req_builder = req_builder.query(&[("orderSource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderOrdersHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit: 10 req/sec/UID
pub async fn mix_order_orders_pending_get(configuration: &configuration::Configuration, product_type: &str, order_id: Option<&str>, client_oid: Option<&str>, symbol: Option<&str>, status: Option<&str>, id_less_than: Option<&str>, start_time: Option<String>, end_time: Option<String>, limit: Option<i32>) -> Result<models::MixOrderOrdersPendingGet200Response, Error<MixOrderOrdersPendingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_type = product_type;
    let p_order_id = order_id;
    let p_client_oid = client_oid;
    let p_symbol = symbol;
    let p_status = status;
    let p_id_less_than = id_less_than;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;

    let uri_str = format!("{}/mix/order/orders-pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_oid {
        req_builder = req_builder.query(&[("clientOid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("productType", &p_product_type.to_string())]);
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderOrdersPendingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit: 10 requests/second/UID<br>Rate limit: 1 request/second/UID for copy trading traders<br><strong>Description</strong><br>Ignore the tradeSide parameter when position mode is in one-way-mode<br>In “hedge-mode”, when there is limit close order occupying the position, if the size of next market close order and limit close orders exceeds the position size, it will return an “insufficient position error” instead of cancelling the current limit order and executing the market order hedge position mode: Open long: \"side\"=buy, \"tradeSide\"=open; Close long: \"side\"=buy, \"tradeSide\"=close; Open short: \"side\"=sell,<br>\"tradeSide\"=open; Close short: \"side\"=sell, \"tradeSide\"=close; one-way position mode: \"side\"=buy and sell,<br>tradeSide: ignore
pub async fn mix_order_place_order_post(configuration: &configuration::Configuration, place_order_request: Option<models::PlaceOrderRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<MixOrderPlaceOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_place_order_request = place_order_request;

    let uri_str = format!("{}/mix/order/place-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_place_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MixOrderPlaceOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

