/*
 * Bitget API
 *
 * Welcome to Bitget Developer document! 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`spot_account_assets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountAssetsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_account_bills_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountBillsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_account_deduct_info_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountDeductInfoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_account_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountInfoGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_account_sub_main_trans_record_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountSubMainTransRecordGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_account_subaccount_assets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountSubaccountAssetsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_account_switch_deduct_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountSwitchDeductPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_account_transfer_records_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotAccountTransferRecordsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_cancel_withdrawal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletCancelWithdrawalPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_deposit_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletDepositAddressGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_deposit_records_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletDepositRecordsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_modify_deposit_account_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletModifyDepositAccountPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_subaccount_deposit_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletSubaccountDepositAddressGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_subaccount_deposit_records_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletSubaccountDepositRecordsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_subaccount_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletSubaccountTransferPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_transfer_coin_info_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletTransferCoinInfoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletTransferPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_withdrawal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletWithdrawalPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_wallet_withdrawal_records_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotWalletWithdrawalRecordsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Frequency limit: 10 times/1s (User ID)
pub async fn spot_account_assets_get(configuration: &configuration::Configuration, coin: Option<&str>, asset_type: Option<&str>) -> Result<models::SpotAccountAssetsGet200Response, Error<SpotAccountAssetsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_asset_type = asset_type;

    let uri_str = format!("{}/spot/account/assets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_asset_type {
        req_builder = req_builder.query(&[("assetType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountAssetsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s (User ID)
pub async fn spot_account_bills_get(configuration: &configuration::Configuration, coin: Option<&str>, group_type: Option<&str>, business_type: Option<&str>, start_time: Option<&str>, end_time: Option<&str>, limit: Option<i32>, id_less_than: Option<&str>) -> Result<models::SpotAccountBillsGet200Response, Error<SpotAccountBillsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_group_type = group_type;
    let p_business_type = business_type;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_limit = limit;
    let p_id_less_than = id_less_than;

    let uri_str = format!("{}/spot/account/bills", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_group_type {
        req_builder = req_builder.query(&[("groupType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_business_type {
        req_builder = req_builder.query(&[("businessType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountBillsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 1 requests/second/UID
pub async fn spot_account_deduct_info_post(configuration: &configuration::Configuration, ) -> Result<models::SpotAccountDeductInfoPost200Response, Error<SpotAccountDeductInfoPostError>> {

    let uri_str = format!("{}/spot/account/deduct-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountDeductInfoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 1 time/1s (User ID)
pub async fn spot_account_info_get(configuration: &configuration::Configuration, ) -> Result<models::SpotAccountInfoGet200Response, Error<SpotAccountInfoGetError>> {

    let uri_str = format!("{}/spot/account/info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountInfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 20 requests/second/UID
pub async fn spot_account_sub_main_trans_record_get(configuration: &configuration::Configuration, coin: Option<&str>, role: Option<&str>, sub_uid: Option<&str>, start_time: Option<&str>, end_time: Option<&str>, client_oid: Option<&str>, limit: Option<i32>, id_less_than: Option<&str>) -> Result<models::SpotAccountSubMainTransRecordGet200Response, Error<SpotAccountSubMainTransRecordGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_role = role;
    let p_sub_uid = sub_uid;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_client_oid = client_oid;
    let p_limit = limit;
    let p_id_less_than = id_less_than;

    let uri_str = format!("{}/spot/account/sub-main-trans-record", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sub_uid {
        req_builder = req_builder.query(&[("subUid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_oid {
        req_builder = req_builder.query(&[("clientOid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountSubMainTransRecordGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s (User ID)
pub async fn spot_account_subaccount_assets_get(configuration: &configuration::Configuration, ) -> Result<models::SpotAccountSubaccountAssetsGet200Response, Error<SpotAccountSubaccountAssetsGetError>> {

    let uri_str = format!("{}/spot/account/subaccount-assets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountSubaccountAssetsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 1 requests/second/UID
pub async fn spot_account_switch_deduct_post(configuration: &configuration::Configuration, spot_account_switch_deduct_post_request: Option<models::SpotAccountSwitchDeductPostRequest>) -> Result<models::SpotAccountSwitchDeductPost200Response, Error<SpotAccountSwitchDeductPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_spot_account_switch_deduct_post_request = spot_account_switch_deduct_post_request;

    let uri_str = format!("{}/spot/account/switch-deduct", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_spot_account_switch_deduct_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountSwitchDeductPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 20 requests/second/UID
pub async fn spot_account_transfer_records_get(configuration: &configuration::Configuration, coin: &str, from_type: &str, start_time: Option<&str>, end_time: Option<&str>, client_oid: Option<&str>, limit: Option<i32>, id_less_than: Option<&str>) -> Result<models::SpotAccountTransferRecordsGet200Response, Error<SpotAccountTransferRecordsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_from_type = from_type;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_client_oid = client_oid;
    let p_limit = limit;
    let p_id_less_than = id_less_than;

    let uri_str = format!("{}/spot/account/transferRecords", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    req_builder = req_builder.query(&[("fromType", &p_from_type.to_string())]);
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_oid {
        req_builder = req_builder.query(&[("clientOid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotAccountTransferRecordsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 1 requests/second/UID<br>The user center can set the switch [Cancel Withdrawal], and there is a 'regret period' of 1 minute to cancel the withdrawal.<br>There is manual review in the preliminary review status, and the withdrawal can be cancelled. Once the initial review is passed or uploaded to the chain, the withdrawal cannot be revoked.<br>Small-amount automatic currency withdrawals do not require manual review, and the withdrawal cannot be revoked.
pub async fn spot_wallet_cancel_withdrawal_post(configuration: &configuration::Configuration, spot_wallet_cancel_withdrawal_post_request: Option<models::SpotWalletCancelWithdrawalPostRequest>) -> Result<models::SpotWalletModifyDepositAccountPost200Response, Error<SpotWalletCancelWithdrawalPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_spot_wallet_cancel_withdrawal_post_request = spot_wallet_cancel_withdrawal_post_request;

    let uri_str = format!("{}/spot/wallet/cancel-withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_spot_wallet_cancel_withdrawal_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletCancelWithdrawalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 requests/second/UID
pub async fn spot_wallet_deposit_address_get(configuration: &configuration::Configuration, coin: &str, chain: Option<&str>, size: Option<&str>) -> Result<models::SpotWalletDepositAddressGet200Response, Error<SpotWalletDepositAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_chain = chain;
    let p_size = size;

    let uri_str = format!("{}/spot/wallet/deposit-address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_chain {
        req_builder = req_builder.query(&[("chain", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletDepositAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s (User ID)
pub async fn spot_wallet_deposit_records_get(configuration: &configuration::Configuration, start_time: &str, end_time: &str, coin: Option<&str>, client_oid: Option<&str>, id_less_than: Option<&str>, order_id: Option<&str>, limit: Option<&str>) -> Result<models::SpotWalletWithdrawalRecordsGet200Response, Error<SpotWalletDepositRecordsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_coin = coin;
    let p_client_oid = client_oid;
    let p_id_less_than = id_less_than;
    let p_order_id = order_id;
    let p_limit = limit;

    let uri_str = format!("{}/spot/wallet/deposit-records", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_oid {
        req_builder = req_builder.query(&[("clientOid", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("startTime", &p_start_time.to_string())]);
    req_builder = req_builder.query(&[("endTime", &p_end_time.to_string())]);
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletDepositRecordsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s (User ID)
pub async fn spot_wallet_modify_deposit_account_post(configuration: &configuration::Configuration, modify_request: Option<models::ModifyRequest>) -> Result<models::SpotWalletModifyDepositAccountPost200Response, Error<SpotWalletModifyDepositAccountPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_modify_request = modify_request;

    let uri_str = format!("{}/spot/wallet/modify-deposit-account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_modify_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletModifyDepositAccountPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 requests/second/UID
pub async fn spot_wallet_subaccount_deposit_address_get(configuration: &configuration::Configuration, coin: &str, chain: Option<&str>, size: Option<&str>) -> Result<models::SpotWalletDepositAddressGet200Response, Error<SpotWalletSubaccountDepositAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coin = coin;
    let p_chain = chain;
    let p_size = size;

    let uri_str = format!("{}/spot/wallet/subaccount-deposit-address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("coin", &p_coin.to_string())]);
    if let Some(ref param_value) = p_chain {
        req_builder = req_builder.query(&[("chain", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletSubaccountDepositAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 requests/second/UID
pub async fn spot_wallet_subaccount_deposit_records_get(configuration: &configuration::Configuration, sub_uid: &str, coin: Option<&str>, start_time: Option<&str>, end_time: Option<&str>, id_less_than: Option<&str>, limit: Option<&str>) -> Result<models::SpotWalletSubaccountDepositRecordsGet200Response, Error<SpotWalletSubaccountDepositRecordsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_uid = sub_uid;
    let p_coin = coin;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_id_less_than = id_less_than;
    let p_limit = limit;

    let uri_str = format!("{}/spot/wallet/subaccount-deposit-records", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("subUid", &p_sub_uid.to_string())]);
    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletSubaccountDepositRecordsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 requests/second/UID</br>The types of transfers supported by this interface include<br>1- Parent account transfer to sub-accounts (only parent account APIKey has access)<br>2- Sub-accounts to parent account (only parent account APIKey has access)<br>3- Sub-accounts transfer to sub-accounts (only the parent account APIKey has access and the sub-accounts belong to same parent account)<br>4- Sub-account inner accounts transfer, e.g. spot to futures(only the parent account APIKey has access, and the fromUserId & toUserId should be same)<br>Only the parent account API Key can use this endpoint, and the API Key must bind IP
pub async fn spot_wallet_subaccount_transfer_post(configuration: &configuration::Configuration, sub_transfer_request: Option<models::SubTransferRequest>) -> Result<models::SpotWalletTransferPost200Response, Error<SpotWalletSubaccountTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_transfer_request = sub_transfer_request;

    let uri_str = format!("{}/spot/wallet/subaccount-transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_sub_transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletSubaccountTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s (User ID)
pub async fn spot_wallet_transfer_coin_info_post(configuration: &configuration::Configuration, from_type: &str, to_type: &str) -> Result<models::SpotWalletTransferCoinInfoPost200Response, Error<SpotWalletTransferCoinInfoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_type = from_type;
    let p_to_type = to_type;

    let uri_str = format!("{}/spot/wallet/transfer-coin-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("fromType", &p_from_type.to_string())]);
    req_builder = req_builder.query(&[("toType", &p_to_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletTransferCoinInfoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 requests/second/UID
pub async fn spot_wallet_transfer_post(configuration: &configuration::Configuration, transfer_request: Option<models::TransferRequest>) -> Result<models::SpotWalletTransferPost200Response, Error<SpotWalletTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_transfer_request = transfer_request;

    let uri_str = format!("{}/spot/wallet/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 5 requests/second/UID</br>Coin withdrawals including on-chain withdrawals and internal transfers(the address needs to be added in the address book on web)
pub async fn spot_wallet_withdrawal_post(configuration: &configuration::Configuration, withdraw_request: Option<models::WithdrawRequest>) -> Result<models::SpotTradePlaceOrderPost200Response, Error<SpotWalletWithdrawalPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdraw_request = withdraw_request;

    let uri_str = format!("{}/spot/wallet/withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_withdraw_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletWithdrawalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Frequency limit: 10 times/1s (User ID)
pub async fn spot_wallet_withdrawal_records_get(configuration: &configuration::Configuration, start_time: &str, end_time: &str, coin: Option<&str>, client_oid: Option<&str>, id_less_than: Option<&str>, order_id: Option<&str>, limit: Option<&str>) -> Result<models::SpotWalletWithdrawalRecordsGet200Response, Error<SpotWalletWithdrawalRecordsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_coin = coin;
    let p_client_oid = client_oid;
    let p_id_less_than = id_less_than;
    let p_order_id = order_id;
    let p_limit = limit;

    let uri_str = format!("{}/spot/wallet/withdrawal-records", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_oid {
        req_builder = req_builder.query(&[("clientOid", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("startTime", &p_start_time.to_string())]);
    req_builder = req_builder.query(&[("endTime", &p_end_time.to_string())]);
    if let Some(ref param_value) = p_id_less_than {
        req_builder = req_builder.query(&[("idLessThan", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotWalletWithdrawalRecordsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

