/*
 * OKX API
 *
 * Welcome to OKX Developer document!   excluded below endpoints as they are if you need them please add and commit to https://github.com/kanekoshoyu/exchange-collection): - Trading Account (this might become needed, will add when we need it) - Block Trading - Financial Producer - Affiliate - Status - Announcement 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`asset_asset_valuation_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetAssetValuationGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_balances_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetBalancesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_bills_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetBillsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_cancel_withdrawal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetCancelWithdrawalPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_convert_currencies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetConvertCurrenciesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_convert_currency_pair_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetConvertCurrencyPairGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_convert_estimate_quote_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetConvertEstimateQuotePostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_convert_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetConvertHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_convert_trade_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetConvertTradePostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_currencies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetCurrenciesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_deposit_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetDepositAddressGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_deposit_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetDepositHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_deposit_withdraw_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetDepositWithdrawStatusGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_exchange_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetExchangeListGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_monthly_statement_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetMonthlyStatementGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_monthly_statement_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetMonthlyStatementPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_non_tradable_assets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetNonTradableAssetsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_transfer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetTransferPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_transfer_state_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetTransferStateGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_withdrawal_history_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetWithdrawalHistoryPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`asset_withdrawal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssetWithdrawalPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fiat_cancel_withdrawal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FiatCancelWithdrawalPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fiat_create_withdrawal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FiatCreateWithdrawalPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fiat_deposit_order_detail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FiatDepositOrderDetailGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fiat_deposit_order_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FiatDepositOrderHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fiat_deposit_payment_methods_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FiatDepositPaymentMethodsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fiat_withdrawal_order_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FiatWithdrawalOrderHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fiat_withdrawal_payment_methods_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FiatWithdrawalPaymentMethodsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_asset_valuation_get(configuration: &configuration::Configuration, ccy: &str) -> Result<models::AssetAssetValuationGet200Response, Error<AssetAssetValuationGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/asset/asset-valuation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetAssetValuationGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the funding account balances of all the assets and the amount that is available or on hold.<br> Only asset information of a currency with a balance greater than 0 will be returned.<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_balances_get(configuration: &configuration::Configuration, ccy: &str) -> Result<models::AssetBalancesGet200Response, Error<AssetBalancesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/asset/balances", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetBalancesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query the billing record in the past month.<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_bills_get(configuration: &configuration::Configuration, ccy: Option<&str>, r#type: Option<i32>, client_id: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::AssetBillsGet200Response, Error<AssetBillsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_type = r#type;
    let p_client_id = client_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/asset/bills", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_id {
        req_builder = req_builder.query(&[("clientId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetBillsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_cancel_withdrawal_post(configuration: &configuration::Configuration, asset_cancel_withdrawal_post_request: Option<models::AssetCancelWithdrawalPostRequest>) -> Result<models::AssetCancelWithdrawalPost200Response, Error<AssetCancelWithdrawalPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset_cancel_withdrawal_post_request = asset_cancel_withdrawal_post_request;

    let uri_str = format!("{}/asset/cancel-withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_asset_cancel_withdrawal_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetCancelWithdrawalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_convert_currencies_get(configuration: &configuration::Configuration, ) -> Result<models::AssetConvertCurrenciesGet200Response, Error<AssetConvertCurrenciesGetError>> {

    let uri_str = format!("{}/asset/convert/currencies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetConvertCurrenciesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_convert_currency_pair_get(configuration: &configuration::Configuration, from_ccy: &str, to_ccy: &str) -> Result<models::AssetConvertCurrencyPairGet200Response, Error<AssetConvertCurrencyPairGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_ccy = from_ccy;
    let p_to_ccy = to_ccy;

    let uri_str = format!("{}/asset/convert/currency-pair", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fromCcy", &p_from_ccy.to_string())]);
    req_builder = req_builder.query(&[("toCcy", &p_to_ccy.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetConvertCurrencyPairGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 10 requests per second<br>Rate limit rule: UserID<br>Rate Limit: 1 request per 5 seconds<br>Rate limit rule: Instrument
pub async fn asset_convert_estimate_quote_post(configuration: &configuration::Configuration, estimation_request: Option<models::EstimationRequest>) -> Result<models::AssetConvertEstimateQuotePost200Response, Error<AssetConvertEstimateQuotePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_estimation_request = estimation_request;

    let uri_str = format!("{}/asset/convert/estimate-quote", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_estimation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetConvertEstimateQuotePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_convert_history_get(configuration: &configuration::Configuration, cl_t_req_id: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>, tag: Option<&str>) -> Result<models::AssetConvertHistoryGet200Response, Error<AssetConvertHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cl_t_req_id = cl_t_req_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_tag = tag;

    let uri_str = format!("{}/asset/convert/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_cl_t_req_id {
        req_builder = req_builder.query(&[("clTReqId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetConvertHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 10 requests per second<br>Rate limit rule: UserID
pub async fn asset_convert_trade_post(configuration: &configuration::Configuration, trade_conversion_request: Option<models::TradeConversionRequest>) -> Result<models::AssetConvertTradePost200Response, Error<AssetConvertTradePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trade_conversion_request = trade_conversion_request;

    let uri_str = format!("{}/asset/convert/trade", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_trade_conversion_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetConvertTradePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a list of all currencies available which are related to the current account's KYC entity.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn asset_currencies_get(configuration: &configuration::Configuration, ccy: &str) -> Result<models::AssetCurrenciesGet200Response, Error<AssetCurrenciesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/asset/currencies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetCurrenciesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the deposit addresses of currencies, including previously-used addresses.<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_deposit_address_get(configuration: &configuration::Configuration, ccy: Option<&str>) -> Result<models::AssetDepositAddressGet200Response, Error<AssetDepositAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/asset/deposit-address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetDepositAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the deposit records according to the currency, deposit status, and time range in reverse chronological order. The 100 most recent records are returned by default.<br>Websocket API is also available, refer to Deposit info channel.<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_deposit_history_get(configuration: &configuration::Configuration, ccy: Option<&str>, dep_id: Option<&str>, from_wd_id: Option<&str>, tx_id: Option<&str>, r#type: Option<&str>, state: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<&str>) -> Result<models::AssetDepositHistoryGet200Response, Error<AssetDepositHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_dep_id = dep_id;
    let p_from_wd_id = from_wd_id;
    let p_tx_id = tx_id;
    let p_type = r#type;
    let p_state = state;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/asset/deposit-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dep_id {
        req_builder = req_builder.query(&[("depId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_wd_id {
        req_builder = req_builder.query(&[("fromWdId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tx_id {
        req_builder = req_builder.query(&[("txId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetDepositHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve deposit's and withdrawal's detailed status and estimated complete time.<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_deposit_withdraw_status_get(configuration: &configuration::Configuration, wd_id: Option<&str>, tx_id: Option<&str>, ccy: Option<&str>, to: Option<&str>, chain: Option<&str>) -> Result<models::AssetDepositWithdrawStatusGet200Response, Error<AssetDepositWithdrawStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wd_id = wd_id;
    let p_tx_id = tx_id;
    let p_ccy = ccy;
    let p_to = to;
    let p_chain = chain;

    let uri_str = format!("{}/asset/deposit-withdraw-status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_wd_id {
        req_builder = req_builder.query(&[("wdId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tx_id {
        req_builder = req_builder.query(&[("txId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chain {
        req_builder = req_builder.query(&[("chain", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetDepositWithdrawStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_exchange_list_get(configuration: &configuration::Configuration, ) -> Result<models::AssetExchangeListGet200Response, Error<AssetExchangeListGetError>> {

    let uri_str = format!("{}/asset/exchange-list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetExchangeListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_monthly_statement_get(configuration: &configuration::Configuration, month: &str) -> Result<models::AssetMonthlyStatementGet200Response, Error<AssetMonthlyStatementGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_month = month;

    let uri_str = format!("{}/asset/monthly-statement", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("month", &p_month.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetMonthlyStatementGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_monthly_statement_post(configuration: &configuration::Configuration, asset_monthly_statement_post_request: Option<models::AssetMonthlyStatementPostRequest>) -> Result<models::PublicTimeGet200Response, Error<AssetMonthlyStatementPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset_monthly_statement_post_request = asset_monthly_statement_post_request;

    let uri_str = format!("{}/asset/monthly-statement", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_asset_monthly_statement_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetMonthlyStatementPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_non_tradable_assets_get(configuration: &configuration::Configuration, ccy: &str) -> Result<models::AssetCurrenciesGet200Response, Error<AssetNonTradableAssetsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/asset/non-tradable-assets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetNonTradableAssetsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Only API keys with Trade privilege can call this endpoint.<br>This endpoint supports the transfer of funds between your funding account and trading account, and from the master account to sub-accounts.<br>Sub-account can transfer out to master account by default. Need to call Set permission of transfer out to grant privilege first if you want sub-account transferring to another sub-account (sub-accounts need to belong to same master account.)<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_transfer_post(configuration: &configuration::Configuration, transfer_request: Option<models::TransferRequest>) -> Result<models::AssetTransferPost200Response, Error<AssetTransferPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_transfer_request = transfer_request;

    let uri_str = format!("{}/asset/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetTransferPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_transfer_state_get(configuration: &configuration::Configuration, trans_id: Option<&str>, client_id: Option<&str>, r#type: Option<&str>) -> Result<models::AssetTransferStateGet200Response, Error<AssetTransferStateGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trans_id = trans_id;
    let p_client_id = client_id;
    let p_type = r#type;

    let uri_str = format!("{}/asset/transfer-state", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_trans_id {
        req_builder = req_builder.query(&[("transId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_id {
        req_builder = req_builder.query(&[("clientId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetTransferStateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the withdrawal records according to the currency, withdrawal status, and time range in reverse chronological order. The 100 most recent records are returned by default.<br>Websocket API is also available, refer to Withdrawal info channel.<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_withdrawal_history_post(configuration: &configuration::Configuration, after: Option<&str>, before: Option<&str>, limit: Option<&str>, ccy: Option<&str>, wd_id: Option<&str>, client_id: Option<&str>, tx_id: Option<&str>, r#type: Option<&str>, state: Option<&str>) -> Result<models::AssetDepositHistoryGet200Response, Error<AssetWithdrawalHistoryPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_ccy = ccy;
    let p_wd_id = wd_id;
    let p_client_id = client_id;
    let p_tx_id = tx_id;
    let p_type = r#type;
    let p_state = state;

    let uri_str = format!("{}/asset/withdrawal-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_wd_id {
        req_builder = req_builder.query(&[("wdId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_id {
        req_builder = req_builder.query(&[("clientId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tx_id {
        req_builder = req_builder.query(&[("txId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetWithdrawalHistoryPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Only supported withdrawal of assets from funding account. Common sub-account does not support withdrawal.<br>Rate Limit: 6 requests per second<br>Rate limit rule: UserID
pub async fn asset_withdrawal_post(configuration: &configuration::Configuration, withdrawal_request: Option<models::WithdrawalRequest>) -> Result<models::AssetWithdrawalPost200Response, Error<AssetWithdrawalPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdrawal_request = withdrawal_request;

    let uri_str = format!("{}/asset/withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_withdrawal_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AssetWithdrawalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 3 requests per second<br>Rate limit rule: UserID
pub async fn fiat_cancel_withdrawal_post(configuration: &configuration::Configuration, fiat_cancel_withdrawal_post_request: Option<models::FiatCancelWithdrawalPostRequest>) -> Result<models::FiatCancelWithdrawalPost200Response, Error<FiatCancelWithdrawalPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fiat_cancel_withdrawal_post_request = fiat_cancel_withdrawal_post_request;

    let uri_str = format!("{}/fiat/cancel-withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_fiat_cancel_withdrawal_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FiatCancelWithdrawalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Initiate a fiat withdrawal request (Authenticated endpoint, Only for API keys with \"Withdrawal\" access)<br>Rate Limit: 3 requests per second<br>Rate limit rule: UserID
pub async fn fiat_create_withdrawal_post(configuration: &configuration::Configuration, create_withdrawal: Option<models::CreateWithdrawal>) -> Result<models::FiatCreateWithdrawalPost200Response, Error<FiatCreateWithdrawalPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_withdrawal = create_withdrawal;

    let uri_str = format!("{}/fiat/create-withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_create_withdrawal);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FiatCreateWithdrawalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 3 requests per second<br>Rate limit rule: UserID
pub async fn fiat_deposit_order_detail_get(configuration: &configuration::Configuration, ord_id: &str) -> Result<models::FiatDepositOrderDetailGet200Response, Error<FiatDepositOrderDetailGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ord_id = ord_id;

    let uri_str = format!("{}/fiat/deposit-order-detail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ordId", &p_ord_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FiatDepositOrderDetailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 3 requests per second<br>Rate limit rule: UserID
pub async fn fiat_deposit_order_history_get(configuration: &configuration::Configuration, transaction_id: &str, ccy: Option<&str>, payment_method: Option<&str>, state: Option<&str>, after: Option<String>, before: Option<String>, limit: Option<&str>) -> Result<models::FiatCreateWithdrawalPost200Response, Error<FiatDepositOrderHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_transaction_id = transaction_id;
    let p_ccy = ccy;
    let p_payment_method = payment_method;
    let p_state = state;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/fiat/deposit-order-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("transactionId", &p_transaction_id.to_string())]);
    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_payment_method {
        req_builder = req_builder.query(&[("paymentMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FiatDepositOrderHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 3 requests per second<br>Rate limit rule: UserID
pub async fn fiat_deposit_payment_methods_get(configuration: &configuration::Configuration, ccy: Option<&str>) -> Result<models::FiatDepositPaymentMethodsGet200Response, Error<FiatDepositPaymentMethodsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/fiat/deposit-payment-methods", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FiatDepositPaymentMethodsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 3 requests per second<br>Rate limit rule: UserID
pub async fn fiat_withdrawal_order_history_get(configuration: &configuration::Configuration, ccy: Option<&str>, payment_method: Option<&str>, state: Option<&str>, after: Option<String>, before: Option<String>, limit: Option<&str>) -> Result<models::FiatWithdrawalOrderHistoryGet200Response, Error<FiatWithdrawalOrderHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_payment_method = payment_method;
    let p_state = state;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/fiat/withdrawal-order-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_payment_method {
        req_builder = req_builder.query(&[("paymentMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FiatWithdrawalOrderHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 3 requests per second<br>Rate limit rule: UserID
pub async fn fiat_withdrawal_payment_methods_get(configuration: &configuration::Configuration, ccy: Option<&str>) -> Result<models::FiatWithdrawalPaymentMethodsGet200Response, Error<FiatWithdrawalPaymentMethodsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/fiat/withdrawal-payment-methods", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FiatWithdrawalPaymentMethodsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

