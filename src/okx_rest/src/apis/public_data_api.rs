/*
 * OKX API
 *
 * Welcome to OKX Developer document!   excluded below endpoints as they are if you need them please add and commit to https://github.com/kanekoshoyu/exchange-collection): - Trading Account (this might become needed, will add when we need it) - Block Trading - Financial Producer - Affiliate - Status - Announcement 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`market_exchange_rate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketExchangeRateGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_history_index_candles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketHistoryIndexCandlesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_history_mark_price_candles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketHistoryMarkPriceCandlesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_index_candles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketIndexCandlesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_index_components_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketIndexComponentsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_index_tickers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketIndexTickersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_mark_price_candles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketMarkPriceCandlesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_open_oracle_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketOpenOracleGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_convert_contract_coin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicConvertContractCoinGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_delivery_exercise_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicDeliveryExerciseHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_discount_rate_interest_free_quota_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicDiscountRateInterestFreeQuotaGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_economic_calendar_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicEconomicCalendarGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_estimated_price_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicEstimatedPriceGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_funding_rate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicFundingRateGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_funding_rate_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicFundingRateHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_instrument_tick_bands_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicInstrumentTickBandsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_instruments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicInstrumentsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_insurance_fund_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicInsuranceFundGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_interest_rate_loan_quota_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicInterestRateLoanQuotaGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_mark_price_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicMarkPriceGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_open_interest_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicOpenInterestGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_opt_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicOptSummaryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_position_tiers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicPositionTiersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_premium_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicPremiumHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_price_limit_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicPriceLimitGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_time_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicTimeGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_underlying_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicUnderlyingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// This interface provides the average exchange rate data for 2 weeks<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn market_exchange_rate_get(configuration: &configuration::Configuration, ) -> Result<models::MarketExchangeRateGet200Response, Error<MarketExchangeRateGetError>> {

    let uri_str = format!("{}/market/exchange-rate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketExchangeRateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the candlestick charts of the index from recent years.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn market_history_index_candles_get(configuration: &configuration::Configuration, inst_id: &str, after: Option<&str>, before: Option<&str>, bar: Option<&str>, limit: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<MarketHistoryIndexCandlesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_after = after;
    let p_before = before;
    let p_bar = bar;
    let p_limit = limit;

    let uri_str = format!("{}/market/history-index-candles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_bar {
        req_builder = req_builder.query(&[("bar", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketHistoryIndexCandlesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the candlestick charts of mark price. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn market_history_mark_price_candles_get(configuration: &configuration::Configuration, inst_id: &str, after: Option<&str>, before: Option<&str>, bar: Option<&str>, limit: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<MarketHistoryMarkPriceCandlesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_after = after;
    let p_before = before;
    let p_bar = bar;
    let p_limit = limit;

    let uri_str = format!("{}/market/history-mark-price-candles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_bar {
        req_builder = req_builder.query(&[("bar", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketHistoryMarkPriceCandlesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the candlestick charts of the index.<br>This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn market_index_candles_get(configuration: &configuration::Configuration, inst_id: &str, after: Option<&str>, before: Option<&str>, bar: Option<&str>, limit: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<MarketIndexCandlesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_after = after;
    let p_before = before;
    let p_bar = bar;
    let p_limit = limit;

    let uri_str = format!("{}/market/index-candles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_bar {
        req_builder = req_builder.query(&[("bar", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketIndexCandlesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the index component information data on the market.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn market_index_components_get(configuration: &configuration::Configuration, index: &str) -> Result<models::MarketIndexComponentsGet200Response, Error<MarketIndexComponentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_index = index;

    let uri_str = format!("{}/market/index-components", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("index", &p_index.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketIndexComponentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit rule: IP +instrumentID
pub async fn market_index_tickers_get(configuration: &configuration::Configuration, inst_id: &str, quote_ccy: Option<&str>) -> Result<models::MarketIndexTickersGet200Response, Error<MarketIndexTickersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_quote_ccy = quote_ccy;

    let uri_str = format!("{}/market/index-tickers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_quote_ccy {
        req_builder = req_builder.query(&[("quoteCcy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketIndexTickersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the candlestick charts of mark price. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn market_mark_price_candles_get(configuration: &configuration::Configuration, inst_id: &str, after: Option<&str>, before: Option<&str>, bar: Option<&str>, limit: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<MarketMarkPriceCandlesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_after = after;
    let p_before = before;
    let p_bar = bar;
    let p_limit = limit;

    let uri_str = format!("{}/market/mark-price-candles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_bar {
        req_builder = req_builder.query(&[("bar", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketMarkPriceCandlesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the crypto price of signing using Open Oracle smart contract.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn market_open_oracle_get(configuration: &configuration::Configuration, ) -> Result<models::MarketOpenOracleGet200Response, Error<MarketOpenOracleGetError>> {

    let uri_str = format!("{}/market/open-oracle", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketOpenOracleGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get insurance fund balance information.<br>Rate limit rule: IP +instrumentID
pub async fn public_convert_contract_coin_get(configuration: &configuration::Configuration, inst_id: &str, sz: &str, r#type: Option<&str>, px: Option<&str>, unit: Option<&str>, op_type: Option<&str>) -> Result<models::PublicConvertContractCoinGet200Response, Error<PublicConvertContractCoinGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_sz = sz;
    let p_type = r#type;
    let p_px = px;
    let p_unit = unit;
    let p_op_type = op_type;

    let uri_str = format!("{}/public/convert-contract-coin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    req_builder = req_builder.query(&[("sz", &p_sz.to_string())]);
    if let Some(ref param_value) = p_px {
        req_builder = req_builder.query(&[("px", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unit {
        req_builder = req_builder.query(&[("unit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_op_type {
        req_builder = req_builder.query(&[("opType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicConvertContractCoinGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve delivery records of Futures and exercise records of Options in the last 3 months.<br>Rate Limit: 40 requests per 2 seconds<br>Rate limit rule: IP + (instrumentType + uly)
pub async fn public_delivery_exercise_history_get(configuration: &configuration::Configuration, inst_type: &str, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>) -> Result<models::PublicDeliveryExerciseHistoryGet200Response, Error<PublicDeliveryExerciseHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;

    let uri_str = format!("{}/public/delivery-exercise-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicDeliveryExerciseHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit rule: IP + InstrumentId
pub async fn public_discount_rate_interest_free_quota_get(configuration: &configuration::Configuration, ccy: Option<&str>) -> Result<models::PublicDiscountRateInterestFreeQuotaGet200Response, Error<PublicDiscountRateInterestFreeQuotaGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;

    let uri_str = format!("{}/public/discount-rate-interest-free-quota", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicDiscountRateInterestFreeQuotaGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the macro-economic calendar data within 3 months. Historical data from 3 months ago is only available to users with trading fee tier VIP1 and above.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn public_economic_calendar_get(configuration: &configuration::Configuration, importance: Option<&str>, before: Option<&str>, after: Option<&str>, limit: Option<&str>) -> Result<models::PublicEconomicCalendarGet200Response, Error<PublicEconomicCalendarGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_importance = importance;
    let p_before = before;
    let p_after = after;
    let p_limit = limit;

    let uri_str = format!("{}/public/economic-calendar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_importance {
        req_builder = req_builder.query(&[("importance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicEconomicCalendarGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve option market data.<br>Rate limit rule: IP + InstrumentId
pub async fn public_estimated_price_get(configuration: &configuration::Configuration, inst_id: Option<&str>) -> Result<models::PublicEstimatedPriceGet200Response, Error<PublicEstimatedPriceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;

    let uri_str = format!("{}/public/estimated-price", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicEstimatedPriceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve funding rate.<br>Rate limit rule: IP + (instrumentType + uly)
pub async fn public_funding_rate_get(configuration: &configuration::Configuration, inst_id: Option<&str>) -> Result<models::PublicFundingRateGet200Response, Error<PublicFundingRateGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;

    let uri_str = format!("{}/public/funding-rate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicFundingRateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve funding rate history. This endpoint can retrieve data from the last 3 months.<br>Rate limit rule: IP + InstrumentId
pub async fn public_funding_rate_history_get(configuration: &configuration::Configuration, inst_id: &str, before: Option<&str>, after: Option<&str>, limit: Option<i32>) -> Result<models::PublicFundingRateGet200Response, Error<PublicFundingRateHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_before = before;
    let p_after = after;
    let p_limit = limit;

    let uri_str = format!("{}/public/funding-rate-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicFundingRateHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get insurance fund balance information.<br>Rate limit rule: IP +instrumentID
pub async fn public_instrument_tick_bands_get(configuration: &configuration::Configuration, inst_family: &str, inst_type: Option<&str>) -> Result<models::PublicInstrumentTickBandsGet200Response, Error<PublicInstrumentTickBandsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_family = inst_family;
    let p_inst_type = inst_type;

    let uri_str = format!("{}/public/instrument-tick-bands", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("instFamily", &p_inst_family.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicInstrumentTickBandsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a list of instruments with open contracts.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP + instrumentType
pub async fn public_instruments_get(configuration: &configuration::Configuration, inst_type: &str, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>) -> Result<models::PublicInstrumentsGet200Response, Error<PublicInstrumentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;

    let uri_str = format!("{}/public/instruments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicInstrumentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get insurance fund balance information.<br>Rate limit rule: IP +instrumentID
pub async fn public_insurance_fund_get(configuration: &configuration::Configuration, inst_type: &str, r#type: Option<&str>, uly: Option<&str>, inst_family: Option<&str>, ccy: Option<&str>, before: Option<&str>, after: Option<&str>, limit: Option<&str>) -> Result<models::PublicInsuranceFundGet200Response, Error<PublicInsuranceFundGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_type = r#type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_ccy = ccy;
    let p_before = before;
    let p_after = after;
    let p_limit = limit;

    let uri_str = format!("{}/public/insurance-fund", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicInsuranceFundGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit rule: IP +instrumentID
pub async fn public_interest_rate_loan_quota_get(configuration: &configuration::Configuration, ) -> Result<models::PublicInterestRateLoanQuotaGet200Response, Error<PublicInterestRateLoanQuotaGetError>> {

    let uri_str = format!("{}/public/interest-rate-loan-quota", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicInterestRateLoanQuotaGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve mark price.<br>We set the mark price based on the SPOT index and at a reasonable basis to prevent individual users from manipulating the market and causing the contract price to fluctuate.<br>Rate Limit: 10 requests per 2 seconds<br>Rate limit rule: IP +instrumentID
pub async fn public_mark_price_get(configuration: &configuration::Configuration, inst_type: &str, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>) -> Result<models::PublicMarkPriceGet200Response, Error<PublicMarkPriceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;

    let uri_str = format!("{}/public/mark-price", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicMarkPriceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the total open interest for contracts on OKX.<br>Rate limit rule: IP + (instrumentType + uly)
pub async fn public_open_interest_get(configuration: &configuration::Configuration, inst_type: &str, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>) -> Result<models::PublicOpenInterestGet200Response, Error<PublicOpenInterestGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;

    let uri_str = format!("{}/public/open-interest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicOpenInterestGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve option market data.<br>Rate limit rule: IP + InstrumentId
pub async fn public_opt_summary_get(configuration: &configuration::Configuration, uly: Option<&str>, inst_family: Option<&str>, exp_time: Option<&str>) -> Result<models::PublicOptSummaryGet200Response, Error<PublicOptSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_exp_time = exp_time;

    let uri_str = format!("{}/public/opt-summary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exp_time {
        req_builder = req_builder.query(&[("expTime", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicOptSummaryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve position tiers information, maximum leverage depends on your borrowings and margin ratio.<br>Rate limit rule: IP +instrumentID
pub async fn public_position_tiers_get(configuration: &configuration::Configuration, inst_type: &str, td_mode: &str, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>, ccy: Option<&str>, tier: Option<&str>) -> Result<models::PublicPositionTiersGet200Response, Error<PublicPositionTiersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_td_mode = td_mode;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;
    let p_ccy = ccy;
    let p_tier = tier;

    let uri_str = format!("{}/public/position-tiers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    req_builder = req_builder.query(&[("tdMode", &p_td_mode.to_string())]);
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ccy {
        req_builder = req_builder.query(&[("ccy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tier {
        req_builder = req_builder.query(&[("tier", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicPositionTiersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// It will return premium data in the past 6 months.<br>Rate limit rule: IP +instrumentID
pub async fn public_premium_history_get(configuration: &configuration::Configuration, inst_id: &str, after: Option<&str>, before: Option<&str>, limit: Option<&str>) -> Result<models::PublicPremiumHistoryGet200Response, Error<PublicPremiumHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/public/premium-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicPremiumHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the highest buy limit and lowest sell limit of the instrument.<br>Rate limit rule: IP + InstrumentId
pub async fn public_price_limit_get(configuration: &configuration::Configuration, inst_id: &str) -> Result<models::PublicPriceLimitGet200Response, Error<PublicPriceLimitGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;

    let uri_str = format!("{}/public/price-limit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicPriceLimitGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit rule: IP + InstrumentId
pub async fn public_time_get(configuration: &configuration::Configuration, ) -> Result<models::PublicTimeGet200Response, Error<PublicTimeGetError>> {

    let uri_str = format!("{}/public/time", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicTimeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit rule: IP +instrumentID
pub async fn public_underlying_get(configuration: &configuration::Configuration, inst_type: &str) -> Result<models::MarketSprdCandlesGet200Response, Error<PublicUnderlyingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;

    let uri_str = format!("{}/public/underlying", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicUnderlyingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

