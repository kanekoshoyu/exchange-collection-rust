/*
 * OKX API
 *
 * Welcome to OKX Developer document!   excluded below endpoints as they are if you need them please add and commit to https://github.com/kanekoshoyu/exchange-collection): - Trading Account (this might become needed, will add when we need it) - Block Trading - Financial Producer - Affiliate - Status - Announcement 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`copytrading_algo_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingAlgoOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_amend_copy_settings_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingAmendCopySettingsPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_amend_profit_sharing_ratio_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingAmendProfitSharingRatioPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_apply_lead_trading_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingApplyLeadTradingPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_batch_leverage_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingBatchLeverageInfoGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_batch_set_leverage_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingBatchSetLeveragePostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_close_subposition_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingCloseSubpositionPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingConfigGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_copy_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingCopySettingsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_copy_traders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingCopyTradersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_current_lead_traders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingCurrentLeadTradersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_current_subpositions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingCurrentSubpositionsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_first_copy_setting_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingFirstCopySettingPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_instruments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingInstrumentsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_lead_traders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingLeadTradersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_performance_current_subpositions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPerformanceCurrentSubpositionsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_performance_subpositions_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPerformanceSubpositionsHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_pnl_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPnlGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_preference_currency_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPreferenceCurrencyGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_profit_sharing_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingProfitSharingDetailsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicConfigGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_copy_traders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicCopyTradersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_current_subpositions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicCurrentSubpositionsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_lead_traders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicLeadTradersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_pnl_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicPnlGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_preference_currency_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicPreferenceCurrencyGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicStatsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_subpositions_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicSubpositionsHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_public_weekly_pnl_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingPublicWeeklyPnlGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_set_instruments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingSetInstrumentsPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingStatsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_stop_copy_trading_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingStopCopyTradingPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_stop_lead_trading_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingStopLeadTradingPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_subpositions_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingSubpositionsHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_total_profit_sharing_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingTotalProfitSharingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_total_unrealized_profit_sharing_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingTotalUnrealizedProfitSharingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_unrealized_profit_sharing_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingUnrealizedProfitSharingDetailsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copytrading_weekly_pnl_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopytradingWeeklyPnlGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_books_full_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketBooksFullGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_books_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketBooksGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_call_auction_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketCallAuctionDetailsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_candles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketCandlesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_history_candles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketHistoryCandlesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_history_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketHistoryTradesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_option_instrument_family_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketOptionInstrumentFamilyTradesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_platform24_volume_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketPlatform24VolumeGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_ticker_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketTickerGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_tickers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketTickersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`market_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketTradesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_option_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicOptionTradesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_account_rate_limit_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeAccountRateLimitGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_amend_algos_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeAmendAlgosPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_amend_batch_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeAmendBatchOrdersPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_amend_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeAmendOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_batch_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeBatchOrdersPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_cancel_algos_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeCancelAlgosPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_cancel_batch_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeCancelBatchOrdersPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_cancel_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeCancelOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_close_position_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeClosePositionPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_easy_convert_currency_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeEasyConvertCurrencyListGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_easy_convert_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeEasyConvertGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_easy_convert_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeEasyConvertHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_easy_convert_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeEasyConvertPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_fills_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeFillsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_fills_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeFillsHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_mass_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeMassCancelPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_one_click_repay_currency_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOneClickRepayCurrencyListGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_one_click_repay_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOneClickRepayHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_one_click_repay_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOneClickRepayPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_order_algo_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrderAlgoGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrderGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_order_precheck_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrderPrecheckPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_orders_algo_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrdersAlgoHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_orders_algo_pending_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrdersAlgoPendingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_orders_history_archive_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrdersHistoryArchiveGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_orders_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrdersHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trade_orders_pending_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradeOrdersPendingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_adjust_investment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridAdjustInvestmentPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_ai_param_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridAiParamGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_amend_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridAmendOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_cancel_close_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridCancelCloseOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_close_position_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridClosePositionPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_compute_margin_balance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridComputeMarginBalancePostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_grid_quantity_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridGridQuantityGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_margin_balance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridMarginBalancePostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_min_investment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridMinInvestmentPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_order_instant_trigger_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridOrderInstantTriggerPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_orders_algo_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridOrdersAlgoDetailsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_orders_algo_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridOrdersAlgoHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_orders_algo_pending_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridOrdersAlgoPendingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_positions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridPositionsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_rsi_back_testing_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridRsiBackTestingPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_stop_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridStopOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_sub_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridSubOrdersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_grid_withdraw_income_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotGridWithdrawIncomePostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_recurring_amend_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotRecurringAmendOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_recurring_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotRecurringOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_recurring_orders_algo_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotRecurringOrdersAlgoDetailsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_recurring_orders_algo_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotRecurringOrdersAlgoHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_recurring_orders_algo_pending_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotRecurringOrdersAlgoPendingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_recurring_stop_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotRecurringStopOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_recurring_sub_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotRecurringSubOrdersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_amend_tpsl_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalAmendTpslPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_cancel_sub_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalCancelSubOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_close_position_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalClosePositionPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_create_signal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalCreateSignalPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_event_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalEventHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_margin_balance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalMarginBalancePostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_orders_algo_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalOrdersAlgoDetailsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_orders_algo_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalOrdersAlgoHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_orders_algo_pending_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalOrdersAlgoPendingGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_positions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalPositionsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_positions_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalPositionsHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_set_instruments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalSetInstrumentsPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_signals_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalSignalsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_stop_order_algo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalStopOrderAlgoPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_sub_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalSubOrderPostError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trading_bot_signal_sub_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradingBotSignalSubOrdersGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Rate limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_algo_order_post(configuration: &configuration::Configuration, lead_place_request: Option<models::LeadPlaceRequest>) -> Result<models::CopytradingAlgoOrderPost200Response, Error<CopytradingAlgoOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lead_place_request = lead_place_request;

    let uri_str = format!("{}/copytrading/algo-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_lead_place_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingAlgoOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You need to use this endpoint to amend copy settings.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_amend_copy_settings_post(configuration: &configuration::Configuration, first_copy_trading: Option<models::FirstCopyTrading>) -> Result<models::CopytradingFirstCopySettingPost200Response, Error<CopytradingAmendCopySettingsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_first_copy_trading = first_copy_trading;

    let uri_str = format!("{}/copytrading/amend-copy-settings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_first_copy_trading);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingAmendCopySettingsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// It is used to amend profit sharing ratio.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_amend_profit_sharing_ratio_post(configuration: &configuration::Configuration, copytrading_amend_profit_sharing_ratio_post_request: Option<models::CopytradingAmendProfitSharingRatioPostRequest>) -> Result<models::CopytradingApplyLeadTradingPost200Response, Error<CopytradingAmendProfitSharingRatioPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_copytrading_amend_profit_sharing_ratio_post_request = copytrading_amend_profit_sharing_ratio_post_request;

    let uri_str = format!("{}/copytrading/amend-profit-sharing-ratio", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_copytrading_amend_profit_sharing_ratio_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingAmendProfitSharingRatioPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Only ND broker sub-account whitelisted can apply for lead trader by this endpoint. It will be passed immediately.<br>Please reach out to BD for help if you want to be whitelisted.<br>For other accounts, e.g. ND main accounts and general main and sub-accounts, still need to apply on the web manually<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_apply_lead_trading_post(configuration: &configuration::Configuration, copytrading_apply_lead_trading_post_request: Option<models::CopytradingApplyLeadTradingPostRequest>) -> Result<models::CopytradingApplyLeadTradingPost200Response, Error<CopytradingApplyLeadTradingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_copytrading_apply_lead_trading_post_request = copytrading_apply_lead_trading_post_request;

    let uri_str = format!("{}/copytrading/apply-lead-trading", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_copytrading_apply_lead_trading_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingApplyLeadTradingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve leverages that belong to the lead trader and you.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_batch_leverage_info_get(configuration: &configuration::Configuration, mgn_mode: &str, unique_code: &str, inst_id: Option<&str>) -> Result<models::CopytradingBatchLeverageInfoGet200Response, Error<CopytradingBatchLeverageInfoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_mgn_mode = mgn_mode;
    let p_unique_code = unique_code;
    let p_inst_id = inst_id;

    let uri_str = format!("{}/copytrading/batch-leverage-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("mgnMode", &p_mgn_mode.to_string())]);
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("uniqueCode", &p_unique_code.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingBatchLeverageInfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve leverages that belong to the lead trader and you.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_batch_set_leverage_post(configuration: &configuration::Configuration, leverages_request: Option<models::LeveragesRequest>) -> Result<models::CopytradingBatchSetLeveragePost200Response, Error<CopytradingBatchSetLeveragePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_leverages_request = leverages_request;

    let uri_str = format!("{}/copytrading/batch-set-leverage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_leverages_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingBatchSetLeveragePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can only close a lead or copy position once a time.<br>It is required to pass subPosId.<br>Rate limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_close_subposition_post(configuration: &configuration::Configuration, lead_sub_position_request: Option<models::LeadSubPositionRequest>) -> Result<models::CopytradingAlgoOrderPost200Response, Error<CopytradingCloseSubpositionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lead_sub_position_request = lead_sub_position_request;

    let uri_str = format!("{}/copytrading/close-subposition", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_lead_sub_position_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingCloseSubpositionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve current account configuration related to copy/lead trading.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_config_get(configuration: &configuration::Configuration, ) -> Result<models::CopytradingConfigGet200Response, Error<CopytradingConfigGetError>> {

    let uri_str = format!("{}/copytrading/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the copy settings about certain lead trader.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_copy_settings_get(configuration: &configuration::Configuration, unique_code: &str, inst_type: Option<&str>) -> Result<models::CopytradingCopySettingsGet200Response, Error<CopytradingCopySettingsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_unique_code = unique_code;
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/copy-settings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("uniqueCode", &p_unique_code.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingCopySettingsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Private endpoint. Retrieve copy trader coming from certain lead trader. Return according to pnl from high to low<br>For requests from the ND sub-account, under the same ND broker, uniqueCode is supported for ND lead trader unique code by this endpoint, but the related public endpoint does not support it.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_copy_traders_get(configuration: &configuration::Configuration, inst_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicCopyTradersGet200Response, Error<CopytradingCopyTradersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/copy-traders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingCopyTradersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve leverages that belong to the lead trader and you.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_current_lead_traders_get(configuration: &configuration::Configuration, inst_type: &str) -> Result<models::CopytradingCurrentLeadTradersGet200Response, Error<CopytradingCurrentLeadTradersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/current-lead-traders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingCurrentLeadTradersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve lead or copy positions that are not closed.<br>Returns reverse chronological order with openTime
pub async fn copytrading_current_subpositions_get(configuration: &configuration::Configuration, inst_type: Option<&str>, inst_id: Option<&str>, unique_code: Option<&str>, sub_pos_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::CopytradingCurrentSubpositionsGet200Response, Error<CopytradingCurrentSubpositionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_inst_id = inst_id;
    let p_unique_code = unique_code;
    let p_sub_pos_type = sub_pos_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/copytrading/current-subpositions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sub_pos_type {
        req_builder = req_builder.query(&[("subPosType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingCurrentSubpositionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The first copy settings for the certain lead trader. You need to first copy settings after stopping copying.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_first_copy_setting_post(configuration: &configuration::Configuration, first_copy_trading: Option<models::FirstCopyTrading>) -> Result<models::CopytradingFirstCopySettingPost200Response, Error<CopytradingFirstCopySettingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_first_copy_trading = first_copy_trading;

    let uri_str = format!("{}/copytrading/first-copy-setting", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_first_copy_trading);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingFirstCopySettingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_instruments_get(configuration: &configuration::Configuration, inst_type: &str) -> Result<models::CopytradingInstrumentsGet200Response, Error<CopytradingInstrumentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/instruments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingInstrumentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve copy trader coming from certain lead trader. Return according to pnl from high to low.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_lead_traders_get(configuration: &configuration::Configuration, inst_type: Option<&str>, sort_type: Option<&str>, state: Option<&str>, min_lead_days: Option<&str>, min_assets: Option<&str>, max_assets: Option<&str>, min_aum: Option<&str>, max_aum: Option<&str>, data_ver: Option<&str>, page: Option<&str>, limit: Option<&str>) -> Result<models::CopytradingLeadTradersGet200Response, Error<CopytradingLeadTradersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_sort_type = sort_type;
    let p_state = state;
    let p_min_lead_days = min_lead_days;
    let p_min_assets = min_assets;
    let p_max_assets = max_assets;
    let p_min_aum = min_aum;
    let p_max_aum = max_aum;
    let p_data_ver = data_ver;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/copytrading/lead-traders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_type {
        req_builder = req_builder.query(&[("sortType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_lead_days {
        req_builder = req_builder.query(&[("minLeadDays", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_assets {
        req_builder = req_builder.query(&[("minAssets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_assets {
        req_builder = req_builder.query(&[("maxAssets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_aum {
        req_builder = req_builder.query(&[("minAum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_aum {
        req_builder = req_builder.query(&[("maxAum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_data_ver {
        req_builder = req_builder.query(&[("dataVer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingLeadTradersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Private endpoint. Get current leading positions of lead trader<br>For requests from the ND sub-account, under the same ND broker, uniqueCode is supported for ND lead trader unique code by this endpoint, but the related public endpoint does not support it.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_performance_current_subpositions_get(configuration: &configuration::Configuration, inst_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicCurrentSubpositionsGet200Response, Error<CopytradingPerformanceCurrentSubpositionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/performance-current-subpositions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPerformanceCurrentSubpositionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Private endpoint. Get current leading positions of lead trader<br>For requests from the ND sub-account, under the same ND broker, uniqueCode is supported for ND lead trader unique code by this endpoint, but the related public endpoint does not support it.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_performance_subpositions_history_get(configuration: &configuration::Configuration, inst_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicSubpositionsHistoryGet200Response, Error<CopytradingPerformanceSubpositionsHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/performance-subpositions-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPerformanceSubpositionsHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Private endpoint. Retrieve lead trader daily pnl. Results are returned in counter chronological order.<br>For requests from the ND sub-account, under the same ND broker, uniqueCode is supported for ND lead trader unique code by this endpoint, but the related public endpoint does not support it.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_pnl_get(configuration: &configuration::Configuration, inst_type: &str, unique_code: Option<&str>, last_days: Option<&str>) -> Result<models::CopytradingPublicWeeklyPnlGet200Response, Error<CopytradingPnlGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;
    let p_last_days = last_days;

    let uri_str = format!("{}/copytrading/pnl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_days {
        req_builder = req_builder.query(&[("lastDays", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPnlGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Private endpoint. The most frequently traded crypto of this lead trader. Results are sorted by ratio from large to small.<br>For requests from the ND sub-account, under the same ND broker, uniqueCode is supported for ND lead trader unique code by this endpoint, but the related public endpoint does not support it.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_preference_currency_get(configuration: &configuration::Configuration, inst_type: &str, unique_code: Option<&str>, last_days: Option<&str>) -> Result<models::CopytradingPublicPreferenceCurrencyGet200Response, Error<CopytradingPreferenceCurrencyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;
    let p_last_days = last_days;

    let uri_str = format!("{}/copytrading/preference-currency", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_days {
        req_builder = req_builder.query(&[("lastDays", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPreferenceCurrencyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The leading trader gets profits shared details for the last 3 months.<br>Rate limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_profit_sharing_details_get(configuration: &configuration::Configuration, after: &str, before: &str, limit: &str, inst_type: Option<&str>) -> Result<models::CopytradingProfitSharingDetailsGet200Response, Error<CopytradingProfitSharingDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/profit-sharing-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("after", &p_after.to_string())]);
    req_builder = req_builder.query(&[("before", &p_before.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingProfitSharingDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve copy trading parameter configuration information of copy settings.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_config_get(configuration: &configuration::Configuration, inst_type: &str) -> Result<models::CopytradingPublicConfigGet200Response, Error<CopytradingPublicConfigGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/public-config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve copy trader coming from certain lead trader. Return according to pnl from high to low.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_copy_traders_get(configuration: &configuration::Configuration, inst_type: Option<&str>, limit: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicCopyTradersGet200Response, Error<CopytradingPublicCopyTradersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_limit = limit;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/public-copy-traders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicCopyTradersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_current_subpositions_get(configuration: &configuration::Configuration, inst_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicCurrentSubpositionsGet200Response, Error<CopytradingPublicCurrentSubpositionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/public-current-subpositions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicCurrentSubpositionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve lead trader ranks.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_lead_traders_get(configuration: &configuration::Configuration, inst_type: Option<&str>, sort_type: Option<&str>, state: Option<&str>, min_lead_days: Option<&str>, min_assets: Option<&str>, max_assets: Option<&str>, min_aum: Option<&str>, max_aum: Option<&str>, data_ver: Option<&str>, page: Option<&str>, limit: Option<&str>) -> Result<models::CopytradingPublicLeadTradersGet200Response, Error<CopytradingPublicLeadTradersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_sort_type = sort_type;
    let p_state = state;
    let p_min_lead_days = min_lead_days;
    let p_min_assets = min_assets;
    let p_max_assets = max_assets;
    let p_min_aum = min_aum;
    let p_max_aum = max_aum;
    let p_data_ver = data_ver;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/copytrading/public-lead-traders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_type {
        req_builder = req_builder.query(&[("sortType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_lead_days {
        req_builder = req_builder.query(&[("minLeadDays", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_assets {
        req_builder = req_builder.query(&[("minAssets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_assets {
        req_builder = req_builder.query(&[("maxAssets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_aum {
        req_builder = req_builder.query(&[("minAum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_aum {
        req_builder = req_builder.query(&[("maxAum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_data_ver {
        req_builder = req_builder.query(&[("dataVer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicLeadTradersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve lead trader daily pnl. Results are returned in counter chronological order.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_pnl_get(configuration: &configuration::Configuration, last_days: &str, inst_type: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicWeeklyPnlGet200Response, Error<CopytradingPublicPnlGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_last_days = last_days;
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/public-pnl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("lastDays", &p_last_days.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicPnlGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve lead trader daily pnl. Results are returned in counter chronological order.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_preference_currency_get(configuration: &configuration::Configuration, inst_type: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicPreferenceCurrencyGet200Response, Error<CopytradingPublicPreferenceCurrencyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/public-preference-currency", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicPreferenceCurrencyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve lead trader daily pnl. Results are returned in counter chronological order.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_stats_get(configuration: &configuration::Configuration, last_days: &str, inst_type: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicStatsGet200Response, Error<CopytradingPublicStatsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_last_days = last_days;
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/public-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("lastDays", &p_last_days.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicStatsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve the lead trader completed leading position of the last 3 months.<br>Returns reverse chronological order with subPosId.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_subpositions_history_get(configuration: &configuration::Configuration, inst_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicSubpositionsHistoryGet200Response, Error<CopytradingPublicSubpositionsHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/public-subpositions-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicSubpositionsHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Public endpoint. Retrieve lead trader weekly pnl. Results are returned in counter chronological order.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_public_weekly_pnl_get(configuration: &configuration::Configuration, inst_type: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicWeeklyPnlGet200Response, Error<CopytradingPublicWeeklyPnlGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/public-weekly-pnl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingPublicWeeklyPnlGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The leading trader can amend current leading instruments, need to set initial leading instruments while applying to become a leading trader.<br>All non-leading instruments can't have position or pending orders for the current request when setting non-leading instruments as leading instruments.<br>Rate limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_set_instruments_post(configuration: &configuration::Configuration, inst_id: &str, inst_type: Option<&str>) -> Result<models::CopytradingInstrumentsGet200Response, Error<CopytradingSetInstrumentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/set-instruments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingSetInstrumentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Private endpoint. Key data related to lead trader performance.<br>For requests from the ND sub-account, under the same ND broker, uniqueCode is supported for ND lead trader unique code by this endpoint, but the related public endpoint does not support it.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_stats_get(configuration: &configuration::Configuration, inst_type: &str, unique_code: Option<&str>, last_days: Option<&str>) -> Result<models::CopytradingPublicStatsGet200Response, Error<CopytradingStatsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;
    let p_last_days = last_days;

    let uri_str = format!("{}/copytrading/stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_days {
        req_builder = req_builder.query(&[("lastDays", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingStatsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_stop_copy_trading_post(configuration: &configuration::Configuration, first_copy_trading: Option<models::FirstCopyTrading>) -> Result<models::CopytradingFirstCopySettingPost200Response, Error<CopytradingStopCopyTradingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_first_copy_trading = first_copy_trading;

    let uri_str = format!("{}/copytrading/stop-copy-trading", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_first_copy_trading);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingStopCopyTradingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Only ND broker sub-account whitelisted can apply for lead trader by this endpoint. It will be passed immediately.<br>Please reach out to BD for help if you want to be whitelisted.<br>For other accounts, e.g. ND main accounts and general main and sub-accounts, still need to apply on the web manually<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_stop_lead_trading_post(configuration: &configuration::Configuration, copytrading_stop_lead_trading_post_request: Option<models::CopytradingStopLeadTradingPostRequest>) -> Result<models::CopytradingApplyLeadTradingPost200Response, Error<CopytradingStopLeadTradingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_copytrading_stop_lead_trading_post_request = copytrading_stop_lead_trading_post_request;

    let uri_str = format!("{}/copytrading/stop-lead-trading", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_copytrading_stop_lead_trading_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingStopLeadTradingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the completed lead or copy position of the last 3 months.<br>Returns reverse chronological order with subPosId.<br>Rate limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_subpositions_history_get(configuration: &configuration::Configuration, inst_type: Option<&str>, inst_id: Option<&str>, sub_pos_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::CopytradingCurrentSubpositionsGet200Response, Error<CopytradingSubpositionsHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_inst_id = inst_id;
    let p_sub_pos_type = sub_pos_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/copytrading/subpositions-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sub_pos_type {
        req_builder = req_builder.query(&[("subPosType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingSubpositionsHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The leading trader gets the total amount of profit shared since joining the platform..<br>Rate limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_total_profit_sharing_get(configuration: &configuration::Configuration, inst_type: Option<&str>) -> Result<models::CopytradingProfitSharingDetailsGet200Response, Error<CopytradingTotalProfitSharingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/total-profit-sharing", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingTotalProfitSharingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The leading trader gets the profit sharing details that are expected to be shared in the next settlement cycle.<br>The unrealized profit sharing details will update once there copy position is closed.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_total_unrealized_profit_sharing_get(configuration: &configuration::Configuration, inst_type: Option<&str>) -> Result<models::CopytradingProfitSharingDetailsGet200Response, Error<CopytradingTotalUnrealizedProfitSharingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/total-unrealized-profit-sharing", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingTotalUnrealizedProfitSharingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The leading trader gets the profit sharing details that are expected to be shared in the next settlement cycle.<br>The unrealized profit sharing details will update once there copy position is closed.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_unrealized_profit_sharing_details_get(configuration: &configuration::Configuration, inst_type: Option<&str>) -> Result<models::CopytradingProfitSharingDetailsGet200Response, Error<CopytradingUnrealizedProfitSharingDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;

    let uri_str = format!("{}/copytrading/unrealized-profit-sharing-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingUnrealizedProfitSharingDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Private endpoint. Retrieve lead trader weekly pnl. Results are returned in counter chronological order.<br>For requests from the ND sub-account, under the same ND broker, uniqueCode is supported for ND lead trader unique code by this endpoint, but the related public endpoint does not support it..<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn copytrading_weekly_pnl_get(configuration: &configuration::Configuration, inst_type: Option<&str>, unique_code: Option<&str>) -> Result<models::CopytradingPublicWeeklyPnlGet200Response, Error<CopytradingWeeklyPnlGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_unique_code = unique_code;

    let uri_str = format!("{}/copytrading/weekly-pnl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unique_code {
        req_builder = req_builder.query(&[("uniqueCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CopytradingWeeklyPnlGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve order book of the instrument. The data will be updated once a second.<br>Rate limit rule: UserID
pub async fn market_books_full_get(configuration: &configuration::Configuration, inst_id: Option<&str>, sz: Option<&str>) -> Result<models::MarketBooksGet200Response, Error<MarketBooksFullGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_sz = sz;

    let uri_str = format!("{}/market/books-full", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sz {
        req_builder = req_builder.query(&[("sz", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketBooksFullGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve order book of the instrument.<br>Rate limit rule: UserID
pub async fn market_books_get(configuration: &configuration::Configuration, inst_id: Option<&str>, sz: Option<&str>) -> Result<models::MarketBooksGet200Response, Error<MarketBooksGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_sz = sz;

    let uri_str = format!("{}/market/books", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sz {
        req_builder = req_builder.query(&[("sz", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketBooksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn market_call_auction_details_get(configuration: &configuration::Configuration, inst_id: &str) -> Result<models::MarketCallAuctionDetailsGet200Response, Error<MarketCallAuctionDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;

    let uri_str = format!("{}/market/call-auction-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketCallAuctionDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the candlestick charts. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.<br>Rate limit rule: UserID
pub async fn market_candles_get(configuration: &configuration::Configuration, inst_id: &str, bar: Option<&str>, after: Option<String>, before: Option<String>, limit: Option<i32>) -> Result<models::TradingBotSignalSubOrderPost200Response, Error<MarketCandlesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_bar = bar;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/market/candles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_bar {
        req_builder = req_builder.query(&[("bar", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketCandlesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve history candlestick charts from recent years(It is last 3 months supported for 1s candlestick)<br>Rate limit rule: UserID
pub async fn market_history_candles_get(configuration: &configuration::Configuration, inst_id: &str, bar: Option<&str>, after: Option<String>, before: Option<String>, limit: Option<i32>) -> Result<models::TradingBotSignalSubOrderPost200Response, Error<MarketHistoryCandlesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_bar = bar;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/market/history-candles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_bar {
        req_builder = req_builder.query(&[("bar", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketHistoryCandlesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the recent transactions of an instrument.<br>Rate limit rule: UserID
pub async fn market_history_trades_get(configuration: &configuration::Configuration, inst_id: &str, r#type: Option<&str>, after: Option<String>, before: Option<String>, limit: Option<i32>) -> Result<models::MarketTradesGet200Response, Error<MarketHistoryTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_type = r#type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/market/history-trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketHistoryTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the recent transactions of an instrument under same instFamily. The maximum is 100.<br>Rate limit rule: UserID
pub async fn market_option_instrument_family_trades_get(configuration: &configuration::Configuration, inst_family: &str) -> Result<models::MarketOptionInstrumentFamilyTradesGet200Response, Error<MarketOptionInstrumentFamilyTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_family = inst_family;

    let uri_str = format!("{}/market/option/instrument-family-trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instFamily", &p_inst_family.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketOptionInstrumentFamilyTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn market_platform24_volume_get(configuration: &configuration::Configuration, ) -> Result<models::MarketPlatform24VolumeGet200Response, Error<MarketPlatform24VolumeGetError>> {

    let uri_str = format!("{}/market/platform-24-volume", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketPlatform24VolumeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the latest price snapshot, best bid/ask price, and trading volume in the last 24 hours.<br>Rate limit rule: UserID
pub async fn market_ticker_get(configuration: &configuration::Configuration, inst_id: Option<&str>) -> Result<models::MarketTickersGet200Response, Error<MarketTickerGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;

    let uri_str = format!("{}/market/ticker", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketTickerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the latest price snapshot, best bid/ask price, and trading volume in the last 24 hours.<br>Rate limit: 5 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn market_tickers_get(configuration: &configuration::Configuration, inst_type: Option<&str>, uly: Option<&str>, before: Option<&str>, limit: Option<&str>, inst_family: Option<&str>) -> Result<models::MarketTickersGet200Response, Error<MarketTickersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_before = before;
    let p_limit = limit;
    let p_inst_family = inst_family;

    let uri_str = format!("{}/market/tickers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketTickersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the recent transactions of an instrument.<br>Rate limit rule: UserID
pub async fn market_trades_get(configuration: &configuration::Configuration, inst_id: &str, limit: Option<i32>) -> Result<models::MarketTradesGet200Response, Error<MarketTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_limit = limit;

    let uri_str = format!("{}/market/trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<MarketTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn public_option_trades_get(configuration: &configuration::Configuration, inst_family: &str, inst_id: &str, opt_type: &str) -> Result<models::PublicOptionTradesGet200Response, Error<PublicOptionTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;
    let p_opt_type = opt_type;

    let uri_str = format!("{}/public/option-trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instFamily", &p_inst_family.to_string())]);
    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    req_builder = req_builder.query(&[("optType", &p_opt_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicOptionTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_account_rate_limit_get(configuration: &configuration::Configuration, ) -> Result<models::TradeAccountRateLimitGet200Response, Error<TradeAccountRateLimitGetError>> {

    let uri_str = format!("{}/trade/account-rate-limit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeAccountRateLimitGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Amend unfilled algo orders (Support Stop order and Trigger order only, not including Move_order_stop order, Iceberg order, TWAP order, Trailing Stop order).<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trade_amend_algos_post(configuration: &configuration::Configuration, trade_amend_algos_post_request: Option<models::TradeAmendAlgosPostRequest>) -> Result<models::TradeOrderAlgoPost200Response, Error<TradeAmendAlgosPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trade_amend_algos_post_request = trade_amend_algos_post_request;

    let uri_str = format!("{}/trade/amend-algos", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_trade_amend_algos_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeAmendAlgosPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Amend an incomplete order.<br>Rate Limit: 60 requests per 2 seconds<br>Rate Limit of lead instruments for Copy Trading: 4 requests per 2 seconds<br>Rate limit rule (except Options): UserID + Instrument ID<br>Rate limit rule (Options only): UserID + Instrument Family<br>Rate limit of this endpoint will also be affected by the rules Sub-account rate limit and Fill ratio based sub-account rate limit.
pub async fn trade_amend_batch_orders_post(configuration: &configuration::Configuration, amend_order_request: Vec<models::AmendOrderRequest>) -> Result<models::TradeOrderPost200Response, Error<TradeAmendBatchOrdersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amend_order_request = amend_order_request;

    let uri_str = format!("{}/trade/amend-batch-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_amend_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeAmendBatchOrdersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Amend an incomplete order.<br>Rate Limit: 60 requests per 2 seconds<br>Rate Limit of lead instruments for Copy Trading: 4 requests per 2 seconds<br>Rate limit rule (except Options): UserID + Instrument ID<br>Rate limit rule (Options only): UserID + Instrument Family<br>Rate limit of this endpoint will also be affected by the rules Sub-account rate limit and Fill ratio based sub-account rate limit.
pub async fn trade_amend_order_post(configuration: &configuration::Configuration, amend_order_request: Vec<models::AmendOrderRequest>) -> Result<models::TradeOrderPost200Response, Error<TradeAmendOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amend_order_request = amend_order_request;

    let uri_str = format!("{}/trade/amend-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_amend_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeAmendOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_batch_orders_post(configuration: &configuration::Configuration, place_order_request: Vec<models::PlaceOrderRequest>) -> Result<models::TradeOrderPost200Response, Error<TradeBatchOrdersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_place_order_request = place_order_request;

    let uri_str = format!("{}/trade/batch-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_place_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeBatchOrdersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel unfilled algo orders. A maximum of 10 orders can be canceled per request. Request parameters should be passed in the form of an array.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule (except Options): UserID + Instrument ID<br>Rate limit rule (Options only): UserID + Instrument Family
pub async fn trade_cancel_algos_post(configuration: &configuration::Configuration, algo_order_request: Option<models::AlgoOrderRequest>) -> Result<models::TradeCancelAlgosPost200Response, Error<TradeCancelAlgosPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_order_request = algo_order_request;

    let uri_str = format!("{}/trade/cancel-algos", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_algo_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeCancelAlgosPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel incomplete orders in batches. Maximum 20 orders can be canceled per request. Request parameters should be passed in the form of an array.<br>Rate Limit: 300 orders per 2 seconds<br>Rate limit rule (except Options): UserID + Instrument ID<br>Rate limit rule (Options only): UserID + Instrument Family
pub async fn trade_cancel_batch_orders_post(configuration: &configuration::Configuration, cancel_order_request: Vec<models::CancelOrderRequest>) -> Result<models::TradeOrderPost200Response, Error<TradeCancelBatchOrdersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cancel_order_request = cancel_order_request;

    let uri_str = format!("{}/trade/cancel-batch-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_cancel_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeCancelBatchOrdersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an incomplete order.<br>Rate Limit: 60 requests per 2 seconds<br>Rate limit rule (except Options): UserID + Instrument ID<br>Rate limit rule (Options only): UserID + Instrument Family
pub async fn trade_cancel_order_post(configuration: &configuration::Configuration, cancel_order_request: models::CancelOrderRequest) -> Result<models::TradeOrderPost200Response, Error<TradeCancelOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cancel_order_request = cancel_order_request;

    let uri_str = format!("{}/trade/cancel-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_cancel_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeCancelOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Close the position of an instrument via a market order.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule (except Options): UserID + Instrument ID<br>Rate limit rule (Options only): UserID + Instrument Family
pub async fn trade_close_position_post(configuration: &configuration::Configuration, close_position_request: models::ClosePositionRequest) -> Result<models::TradeClosePositionPost200Response, Error<TradeClosePositionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_close_position_request = close_position_request;

    let uri_str = format!("{}/trade/close-position", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_close_position_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeClosePositionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_easy_convert_currency_list_get(configuration: &configuration::Configuration, source: Option<&str>) -> Result<models::TradeEasyConvertCurrencyListGet200Response, Error<TradeEasyConvertCurrencyListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_source = source;

    let uri_str = format!("{}/trade/easy-convert-currency-list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeEasyConvertCurrencyListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_easy_convert_get(configuration: &configuration::Configuration, from_ccy: Vec<String>, to_ccy: &str, source: Option<&str>) -> Result<models::TradeEasyConvertGet200Response, Error<TradeEasyConvertGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_from_ccy = from_ccy;
    let p_to_ccy = to_ccy;
    let p_source = source;

    let uri_str = format!("{}/trade/easy-convert", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_from_ccy.into_iter().map(|p| ("fromCcy".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("fromCcy", &p_from_ccy.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    req_builder = req_builder.query(&[("toCcy", &p_to_ccy.to_string())]);
    if let Some(ref param_value) = p_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeEasyConvertGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the history and status of easy convert trades in the past 7 days.<br>Rate Limit: 1 request per 2 seconds<br>Rate limit rule: UserID
pub async fn trade_easy_convert_history_get(configuration: &configuration::Configuration, after: Option<&str>, before: Option<&str>, limit: Option<&str>) -> Result<models::TradeEasyConvertGet200Response, Error<TradeEasyConvertHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/trade/easy-convert-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeEasyConvertHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_easy_convert_post(configuration: &configuration::Configuration, place_conversion_request: Option<models::PlaceConversionRequest>) -> Result<models::TradeEasyConvertGet200Response, Error<TradeEasyConvertPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_place_conversion_request = place_conversion_request;

    let uri_str = format!("{}/trade/easy-convert", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_place_conversion_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeEasyConvertPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve recently-filled transaction details in the last 3 day.<br>Rate Limit: 60 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trade_fills_get(configuration: &configuration::Configuration, inst_type: Option<&str>, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>, ord_id: Option<&str>, sub_type: Option<i32>, after: Option<&str>, before: Option<&str>, begin: Option<i64>, end: Option<i64>, limit: Option<i32>) -> Result<models::TradeFillsGet200Response, Error<TradeFillsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;
    let p_ord_id = ord_id;
    let p_sub_type = sub_type;
    let p_after = after;
    let p_before = before;
    let p_begin = begin;
    let p_end = end;
    let p_limit = limit;

    let uri_str = format!("{}/trade/fills", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ord_id {
        req_builder = req_builder.query(&[("ordId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sub_type {
        req_builder = req_builder.query(&[("subType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeFillsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_fills_history_get(configuration: &configuration::Configuration, inst_type: Option<&str>, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>, ord_id: Option<&str>, sub_type: Option<i32>, after: Option<&str>, before: Option<&str>, begin: Option<i64>, end: Option<i64>, limit: Option<i32>) -> Result<models::TradeFillsGet200Response, Error<TradeFillsHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;
    let p_ord_id = ord_id;
    let p_sub_type = sub_type;
    let p_after = after;
    let p_before = before;
    let p_begin = begin;
    let p_end = end;
    let p_limit = limit;

    let uri_str = format!("{}/trade/fills-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ord_id {
        req_builder = req_builder.query(&[("ordId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sub_type {
        req_builder = req_builder.query(&[("subType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeFillsHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_mass_cancel_post(configuration: &configuration::Configuration, mass_cancel_request: Option<models::MassCancelRequest>) -> Result<models::TradeMassCancelPost200Response, Error<TradeMassCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_mass_cancel_request = mass_cancel_request;

    let uri_str = format!("{}/trade/mass-cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_mass_cancel_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeMassCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of debt currency data and repay currencies. Debt currencies include both cross and isolated debts.<br>Rate Limit: 1 request per 2 seconds<br>Rate limit rule: UserID
pub async fn trade_one_click_repay_currency_list_get(configuration: &configuration::Configuration, dept_type: Option<&str>) -> Result<models::TradeOneClickRepayCurrencyListGet200Response, Error<TradeOneClickRepayCurrencyListGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_dept_type = dept_type;

    let uri_str = format!("{}/trade/one-click-repay-currency-list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_dept_type {
        req_builder = req_builder.query(&[("deptType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOneClickRepayCurrencyListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_one_click_repay_history_get(configuration: &configuration::Configuration, after: Option<&str>, before: Option<&str>, limit: Option<&str>) -> Result<models::TradeEasyConvertGet200Response, Error<TradeOneClickRepayHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/trade/one-click-repay-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOneClickRepayHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_one_click_repay_post(configuration: &configuration::Configuration, dept_type: Option<&str>, debt_repay_request: Option<models::DebtRepayRequest>) -> Result<models::TradeEasyConvertGet200Response, Error<TradeOneClickRepayPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_dept_type = dept_type;
    let p_debt_repay_request = debt_repay_request;

    let uri_str = format!("{}/trade/one-click-repay", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_dept_type {
        req_builder = req_builder.query(&[("deptType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_debt_repay_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOneClickRepayPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trade_order_algo_get(configuration: &configuration::Configuration, algo_id: Option<&str>, algo_cl_ord_id: Option<&str>) -> Result<models::TradeOrderAlgoGet200Response, Error<TradeOrderAlgoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_id = algo_id;
    let p_algo_cl_ord_id = algo_cl_ord_id;

    let uri_str = format!("{}/trade/order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_algo_id {
        req_builder = req_builder.query(&[("algoId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_algo_cl_ord_id {
        req_builder = req_builder.query(&[("algoClOrdId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrderAlgoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The algo order includes trigger order, oco order, conditional order, twap order and trailing order.<br>Rate Limit: 20 requests per 2 seconds<br>Rate Limit of lead instruments for Copy Trading: 1 request per 2 seconds<br>Rate limit rule (except Options): UserID + Instrument ID<br>Rate limit rule (Options only): UserID + Instrument Family
pub async fn trade_order_algo_post(configuration: &configuration::Configuration, trade_order_algo_post_request: Option<models::TradeOrderAlgoPostRequest>) -> Result<models::TradeOrderAlgoPost200Response, Error<TradeOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trade_order_algo_post_request = trade_order_algo_post_request;

    let uri_str = format!("{}/trade/order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_trade_order_algo_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_order_get(configuration: &configuration::Configuration, inst_id: &str, ord_id: Option<&str>, cl_ord_id: Option<&str>) -> Result<models::TradeOrderGet200Response, Error<TradeOrderGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_ord_id = ord_id;
    let p_cl_ord_id = cl_ord_id;

    let uri_str = format!("{}/trade/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_ord_id {
        req_builder = req_builder.query(&[("ordId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cl_ord_id {
        req_builder = req_builder.query(&[("clOrdId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrderGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_order_post(configuration: &configuration::Configuration, place_order_request: models::PlaceOrderRequest) -> Result<models::TradeOrderPost200Response, Error<TradeOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_place_order_request = place_order_request;

    let uri_str = format!("{}/trade/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_place_order_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_order_precheck_post(configuration: &configuration::Configuration, precheck_response: Option<models::PrecheckResponse>) -> Result<models::TradeOrderPrecheckPost200Response, Error<TradeOrderPrecheckPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_precheck_response = precheck_response;

    let uri_str = format!("{}/trade/order-precheck", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_precheck_response);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrderPrecheckPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_orders_algo_history_get(configuration: &configuration::Configuration, r#type: &str, state: Option<&str>, algo_id: Option<&str>, inst_type: Option<&str>, inst_id: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderAlgoGet200Response, Error<TradeOrdersAlgoHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_state = state;
    let p_algo_id = algo_id;
    let p_inst_type = inst_type;
    let p_inst_id = inst_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/trade/orders-algo-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("Type", &p_type.to_string())]);
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_algo_id {
        req_builder = req_builder.query(&[("algoId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrdersAlgoHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trade_orders_algo_pending_get(configuration: &configuration::Configuration, ord_type: Option<&str>, algo_id: Option<&str>, algo_cl_ord_id: Option<&str>, inst_type: Option<&str>, inst_id: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderAlgoGet200Response, Error<TradeOrdersAlgoPendingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ord_type = ord_type;
    let p_algo_id = algo_id;
    let p_algo_cl_ord_id = algo_cl_ord_id;
    let p_inst_type = inst_type;
    let p_inst_id = inst_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/trade/orders-algo-pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ord_type {
        req_builder = req_builder.query(&[("ordType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_algo_id {
        req_builder = req_builder.query(&[("algoId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_algo_cl_ord_id {
        req_builder = req_builder.query(&[("algoClOrdId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrdersAlgoPendingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get completed orders which are placed in the last 7 days, including those placed 3 months ago but completed in the last 7 days.<br>The incomplete orders that have been canceled are only reserved for 2 hours.<br>Rate Limit: 40 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trade_orders_history_archive_get(configuration: &configuration::Configuration, inst_type: &str, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>, ord_type: Option<&str>, state: Option<&str>, category: Option<&str>, after: Option<&str>, before: Option<&str>, begin: Option<&str>, end: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderGet200Response, Error<TradeOrdersHistoryArchiveGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;
    let p_ord_type = ord_type;
    let p_state = state;
    let p_category = category;
    let p_after = after;
    let p_before = before;
    let p_begin = begin;
    let p_end = end;
    let p_limit = limit;

    let uri_str = format!("{}/trade/orders-history-archive", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ord_type {
        req_builder = req_builder.query(&[("ordType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category {
        req_builder = req_builder.query(&[("category", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrdersHistoryArchiveGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get completed orders which are placed in the last 7 days, including those placed 7 days ago but completed in the last 7 days.<br>The incomplete orders that have been canceled are only reserved for 2 hours.<br>Rate Limit: 40 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trade_orders_history_get(configuration: &configuration::Configuration, inst_type: &str, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>, ord_type: Option<&str>, state: Option<&str>, category: Option<&str>, after: Option<&str>, before: Option<&str>, begin: Option<&str>, end: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderGet200Response, Error<TradeOrdersHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;
    let p_ord_type = ord_type;
    let p_state = state;
    let p_category = category;
    let p_after = after;
    let p_before = before;
    let p_begin = begin;
    let p_end = end;
    let p_limit = limit;

    let uri_str = format!("{}/trade/orders-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ord_type {
        req_builder = req_builder.query(&[("ordType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category {
        req_builder = req_builder.query(&[("category", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrdersHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve all incomplete orders under the current account.<br>Rate Limit: 60 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trade_orders_pending_get(configuration: &configuration::Configuration, inst_type: Option<&str>, uly: Option<&str>, inst_family: Option<&str>, inst_id: Option<&str>, ord_type: Option<&str>, state: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderGet200Response, Error<TradeOrdersPendingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_type = inst_type;
    let p_uly = uly;
    let p_inst_family = inst_family;
    let p_inst_id = inst_id;
    let p_ord_type = ord_type;
    let p_state = state;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/trade/orders-pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_uly {
        req_builder = req_builder.query(&[("uly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_family {
        req_builder = req_builder.query(&[("instFamily", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ord_type {
        req_builder = req_builder.query(&[("ordType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradeOrdersPendingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_adjust_investment_post(configuration: &configuration::Configuration, trading_bot_grid_adjust_investment_post_request: Option<models::TradingBotGridAdjustInvestmentPostRequest>) -> Result<models::TradingBotGridAdjustInvestmentPost200Response, Error<TradingBotGridAdjustInvestmentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_grid_adjust_investment_post_request = trading_bot_grid_adjust_investment_post_request;

    let uri_str = format!("{}/tradingBot/grid/adjust-investment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_trading_bot_grid_adjust_investment_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridAdjustInvestmentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_ai_param_get(configuration: &configuration::Configuration, algo_ord_type: &str, inst_id: &str, direction: Option<&str>, duration: Option<&str>) -> Result<models::TradingBotGridAiParamGet200Response, Error<TradingBotGridAiParamGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_inst_id = inst_id;
    let p_direction = direction;
    let p_duration = duration;

    let uri_str = format!("{}/tradingBot/grid/ai-param", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_duration {
        req_builder = req_builder.query(&[("duration", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridAiParamGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_grid_amend_order_algo_post(configuration: &configuration::Configuration, grid_amend_request: Option<models::GridAmendRequest>) -> Result<models::TradeOrderPost200Response, Error<TradingBotGridAmendOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grid_amend_request = grid_amend_request;

    let uri_str = format!("{}/tradingBot/grid/amend-order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_grid_amend_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridAmendOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_grid_cancel_close_order_post(configuration: &configuration::Configuration, bot_close_request: Option<models::BotCloseRequest>) -> Result<models::TradeOrderPost200Response, Error<TradingBotGridCancelCloseOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_bot_close_request = bot_close_request;

    let uri_str = format!("{}/tradingBot/grid/cancel-close-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_bot_close_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridCancelCloseOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_grid_close_position_post(configuration: &configuration::Configuration, bot_close_position_request: Option<models::BotClosePositionRequest>) -> Result<models::TradeOrderPost200Response, Error<TradingBotGridClosePositionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_bot_close_position_request = bot_close_position_request;

    let uri_str = format!("{}/tradingBot/grid/close-position", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_bot_close_position_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridClosePositionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_compute_margin_balance_post(configuration: &configuration::Configuration, trading_bot_grid_compute_margin_balance_post_request: Option<models::TradingBotGridComputeMarginBalancePostRequest>) -> Result<models::TradingBotGridComputeMarginBalancePost200Response, Error<TradingBotGridComputeMarginBalancePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_grid_compute_margin_balance_post_request = trading_bot_grid_compute_margin_balance_post_request;

    let uri_str = format!("{}/tradingBot/grid/compute-margin-balance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_trading_bot_grid_compute_margin_balance_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridComputeMarginBalancePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Maximum grid quantity can be retrieved from this endpoint. Minimum grid quantity always is 2.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_grid_quantity_get(configuration: &configuration::Configuration, inst_id: &str, run_type: &str, algo_ord_type: &str, max_px: &str, min_px: &str, lever: Option<&str>) -> Result<models::TradingBotGridGridQuantityGet200Response, Error<TradingBotGridGridQuantityGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_run_type = run_type;
    let p_algo_ord_type = algo_ord_type;
    let p_max_px = max_px;
    let p_min_px = min_px;
    let p_lever = lever;

    let uri_str = format!("{}/tradingBot/grid/grid-quantity", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    req_builder = req_builder.query(&[("runType", &p_run_type.to_string())]);
    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("maxPx", &p_max_px.to_string())]);
    req_builder = req_builder.query(&[("minPx", &p_min_px.to_string())]);
    if let Some(ref param_value) = p_lever {
        req_builder = req_builder.query(&[("lever", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridGridQuantityGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_margin_balance_post(configuration: &configuration::Configuration, trading_bot_grid_compute_margin_balance_post_request: Option<models::TradingBotGridComputeMarginBalancePostRequest>) -> Result<models::TradingBotGridOrderInstantTriggerPost200Response, Error<TradingBotGridMarginBalancePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_grid_compute_margin_balance_post_request = trading_bot_grid_compute_margin_balance_post_request;

    let uri_str = format!("{}/tradingBot/grid/margin-balance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_trading_bot_grid_compute_margin_balance_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridMarginBalancePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_min_investment_post(configuration: &configuration::Configuration, min_investment_request: Option<models::MinInvestmentRequest>) -> Result<models::TradingBotGridMinInvestmentPost200Response, Error<TradingBotGridMinInvestmentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_min_investment_request = min_investment_request;

    let uri_str = format!("{}/tradingBot/grid/min-investment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_min_investment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridMinInvestmentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Grid trading works by the simple strategy of buy low and sell high. After you set the parameters, the system automatically places orders at incrementally increasing or decreasing prices. Overall, the grid bot seeks to capitalize on normal price volatility by placing buy and sell orders at certain regular intervals above and below a predefined base price.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_order_algo_post(configuration: &configuration::Configuration, trading_bot_grid_order_algo_post_request: Option<models::TradingBotGridOrderAlgoPostRequest>) -> Result<models::TradeOrderPost200Response, Error<TradingBotGridOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_grid_order_algo_post_request = trading_bot_grid_order_algo_post_request;

    let uri_str = format!("{}/tradingBot/grid/order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_trading_bot_grid_order_algo_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_order_instant_trigger_post(configuration: &configuration::Configuration, bot_trigger_request: Option<models::BotTriggerRequest>) -> Result<models::TradingBotGridOrderInstantTriggerPost200Response, Error<TradingBotGridOrderInstantTriggerPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_bot_trigger_request = bot_trigger_request;

    let uri_str = format!("{}/tradingBot/grid/order-instant-trigger", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_bot_trigger_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridOrderInstantTriggerPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_orders_algo_details_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: Option<&str>) -> Result<models::TradingBotGridOrdersAlgoPendingGet200Response, Error<TradingBotGridOrdersAlgoDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;

    let uri_str = format!("{}/tradingBot/grid/orders-algo-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    if let Some(ref param_value) = p_algo_id {
        req_builder = req_builder.query(&[("algoId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridOrdersAlgoDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_orders_algo_history_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: Option<&str>, inst_id: Option<&str>, inst_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradingBotGridOrdersAlgoPendingGet200Response, Error<TradingBotGridOrdersAlgoHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;
    let p_inst_id = inst_id;
    let p_inst_type = inst_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/grid/orders-algo-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    if let Some(ref param_value) = p_algo_id {
        req_builder = req_builder.query(&[("algoId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridOrdersAlgoHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_orders_algo_pending_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: Option<&str>, inst_id: Option<&str>, inst_type: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradingBotGridOrdersAlgoPendingGet200Response, Error<TradingBotGridOrdersAlgoPendingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;
    let p_inst_id = inst_id;
    let p_inst_type = inst_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/grid/orders-algo-pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    if let Some(ref param_value) = p_algo_id {
        req_builder = req_builder.query(&[("algoId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_id {
        req_builder = req_builder.query(&[("instId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_inst_type {
        req_builder = req_builder.query(&[("instType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridOrdersAlgoPendingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_positions_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: &str) -> Result<models::TradeOrderPost200Response, Error<TradingBotGridPositionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;

    let uri_str = format!("{}/tradingBot/grid/positions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridPositionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_rsi_back_testing_post(configuration: &configuration::Configuration, inst_id: &str, timeframe: &str, thold: &str, time_period: &str, trigger_cond: Option<&str>, duration: Option<&str>) -> Result<models::TradingBotGridRsiBackTestingPost200Response, Error<TradingBotGridRsiBackTestingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_timeframe = timeframe;
    let p_thold = thold;
    let p_time_period = time_period;
    let p_trigger_cond = trigger_cond;
    let p_duration = duration;

    let uri_str = format!("{}/tradingBot/grid/rsi-back-testing", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    req_builder = req_builder.query(&[("timeframe", &p_timeframe.to_string())]);
    req_builder = req_builder.query(&[("thold", &p_thold.to_string())]);
    req_builder = req_builder.query(&[("timePeriod", &p_time_period.to_string())]);
    if let Some(ref param_value) = p_trigger_cond {
        req_builder = req_builder.query(&[("triggerCond", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_duration {
        req_builder = req_builder.query(&[("duration", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridRsiBackTestingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_grid_stop_order_algo_post(configuration: &configuration::Configuration, grid_stop_request: Option<models::GridStopRequest>) -> Result<models::TradeOrderPost200Response, Error<TradingBotGridStopOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_grid_stop_request = grid_stop_request;

    let uri_str = format!("{}/tradingBot/grid/stop-order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_grid_stop_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridStopOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_sub_orders_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: &str, r#type: &str, group_id: Option<&str>, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderPost200Response, Error<TradingBotGridSubOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;
    let p_type = r#type;
    let p_group_id = group_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/grid/sub-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_group_id {
        req_builder = req_builder.query(&[("groupId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridSubOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_grid_withdraw_income_post(configuration: &configuration::Configuration, trading_bot_grid_withdraw_income_post_request: Option<models::TradingBotGridWithdrawIncomePostRequest>) -> Result<models::TradingBotGridWithdrawIncomePost200Response, Error<TradingBotGridWithdrawIncomePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_grid_withdraw_income_post_request = trading_bot_grid_withdraw_income_post_request;

    let uri_str = format!("{}/tradingBot/grid/withdraw-income", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_trading_bot_grid_withdraw_income_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotGridWithdrawIncomePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trading_bot_recurring_amend_order_algo_post(configuration: &configuration::Configuration, recurring_amend_order: Option<models::RecurringAmendOrder>) -> Result<models::TradeOrderPost200Response, Error<TradingBotRecurringAmendOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_recurring_amend_order = recurring_amend_order;

    let uri_str = format!("{}/tradingBot/recurring/amend-order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_recurring_amend_order);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotRecurringAmendOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Recurring buy is a strategy for investing a fixed amount in crypto at fixed intervals. An appropriate recurring approach in volatile markets allows you to buy crypto at lower costs.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_recurring_order_algo_post(configuration: &configuration::Configuration, recurring_order: Option<models::RecurringOrder>) -> Result<models::TradeOrderPost200Response, Error<TradingBotRecurringOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_recurring_order = recurring_order;

    let uri_str = format!("{}/tradingBot/recurring/order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_recurring_order);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotRecurringOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trading_bot_recurring_orders_algo_details_get(configuration: &configuration::Configuration, algo_id: &str) -> Result<models::TradingBotRecurringOrdersAlgoPendingGet200Response, Error<TradingBotRecurringOrdersAlgoDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_id = algo_id;

    let uri_str = format!("{}/tradingBot/recurring/orders-algo-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotRecurringOrdersAlgoDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trading_bot_recurring_orders_algo_history_get(configuration: &configuration::Configuration, algo_id: &str, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradingBotRecurringOrdersAlgoPendingGet200Response, Error<TradingBotRecurringOrdersAlgoHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_id = algo_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/recurring/orders-algo-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotRecurringOrdersAlgoHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trading_bot_recurring_orders_algo_pending_get(configuration: &configuration::Configuration, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradingBotRecurringOrdersAlgoPendingGet200Response, Error<TradingBotRecurringOrdersAlgoPendingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/recurring/orders-algo-pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotRecurringOrdersAlgoPendingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trading_bot_recurring_stop_order_algo_post(configuration: &configuration::Configuration, trading_bot_grid_adjust_investment_post200_response_all_of_data_inner: Option<models::TradingBotGridAdjustInvestmentPost200ResponseAllOfDataInner>) -> Result<models::TradeOrderPost200Response, Error<TradingBotRecurringStopOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_grid_adjust_investment_post200_response_all_of_data_inner = trading_bot_grid_adjust_investment_post200_response_all_of_data_inner;

    let uri_str = format!("{}/tradingBot/recurring/stop-order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };
    req_builder = req_builder.json(&p_trading_bot_grid_adjust_investment_post200_response_all_of_data_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotRecurringStopOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn trading_bot_recurring_sub_orders_get(configuration: &configuration::Configuration, algo_id: &str, ord_id: &str, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradeOrderGet200Response, Error<TradingBotRecurringSubOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_id = algo_id;
    let p_ord_id = ord_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/recurring/sub-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    req_builder = req_builder.query(&[("ordId", &p_ord_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-SIGN", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-PASSPHRASE", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("OK-ACCESS-TIMESTAMP", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotRecurringSubOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_amend_tpsl_post(configuration: &configuration::Configuration, tpsl_signal: Option<models::TpslSignal>) -> Result<models::TradingBotGridAdjustInvestmentPost200Response, Error<TradingBotSignalAmendTpslPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tpsl_signal = tpsl_signal;

    let uri_str = format!("{}/tradingBot/signal/amendTPSL", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_tpsl_signal);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalAmendTpslPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_signal_cancel_sub_order_post(configuration: &configuration::Configuration, cancel_order: Option<models::CancelOrder>) -> Result<models::TradingBotSignalCancelSubOrderPost200Response, Error<TradingBotSignalCancelSubOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cancel_order = cancel_order;

    let uri_str = format!("{}/tradingBot/signal/cancel-sub-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_cancel_order);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalCancelSubOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the updated position data for the last 3 months. Return in reverse chronological order using utime.
pub async fn trading_bot_signal_close_position_post(configuration: &configuration::Configuration, trading_bot_signal_close_position_post_request: Option<models::TradingBotSignalClosePositionPostRequest>) -> Result<models::TradingBotGridAdjustInvestmentPost200Response, Error<TradingBotSignalClosePositionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_signal_close_position_post_request = trading_bot_signal_close_position_post_request;

    let uri_str = format!("{}/tradingBot/signal/close-position", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_trading_bot_signal_close_position_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalClosePositionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_create_signal_post(configuration: &configuration::Configuration, signal_request: Option<models::SignalRequest>) -> Result<models::TradingBotSignalCreateSignalPost200Response, Error<TradingBotSignalCreateSignalPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_signal_request = signal_request;

    let uri_str = format!("{}/tradingBot/signal/create-signal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_signal_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalCreateSignalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_signal_event_history_get(configuration: &configuration::Configuration, algo_id: &str, algo_ord_type: &str, after: Option<&str>, before: Option<&str>, limit: Option<i32>) -> Result<models::TradingBotSignalEventHistoryGet200Response, Error<TradingBotSignalEventHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_id = algo_id;
    let p_algo_ord_type = algo_ord_type;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/signal/event-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalEventHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_margin_balance_post(configuration: &configuration::Configuration, margin_signal: Option<models::MarginSignal>) -> Result<models::TradingBotGridAdjustInvestmentPost200Response, Error<TradingBotSignalMarginBalancePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_margin_signal = margin_signal;

    let uri_str = format!("{}/tradingBot/signal/margin-balance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_margin_signal);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalMarginBalancePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_order_algo_post(configuration: &configuration::Configuration, signals_request: Option<models::SignalsRequest>) -> Result<models::TradingBotSignalOrderAlgoPost200Response, Error<TradingBotSignalOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_signals_request = signals_request;

    let uri_str = format!("{}/tradingBot/signal/order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_signals_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_orders_algo_details_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: &str) -> Result<models::TradingBotSignalOrdersAlgoDetailsGet200Response, Error<TradingBotSignalOrdersAlgoDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;

    let uri_str = format!("{}/tradingBot/signal/orders-algo-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalOrdersAlgoDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_orders_algo_history_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: &str, after: Option<&str>, before: Option<&str>, limit: Option<&str>) -> Result<models::TradingBotSignalOrdersAlgoPendingGet200Response, Error<TradingBotSignalOrdersAlgoHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/signal/orders-algo-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalOrdersAlgoHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_orders_algo_pending_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: &str, after: Option<&str>, before: Option<&str>, limit: Option<&str>) -> Result<models::TradingBotSignalOrdersAlgoPendingGet200Response, Error<TradingBotSignalOrdersAlgoPendingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/signal/orders-algo-pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalOrdersAlgoPendingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_positions_get(configuration: &configuration::Configuration, algo_ord_type: &str, algo_id: &str) -> Result<models::TradingBotSignalPositionsGet200Response, Error<TradingBotSignalPositionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_ord_type = algo_ord_type;
    let p_algo_id = algo_id;

    let uri_str = format!("{}/tradingBot/signal/positions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalPositionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the updated position data for the last 3 months. Return in reverse chronological order using utime.
pub async fn trading_bot_signal_positions_history_get(configuration: &configuration::Configuration, inst_id: &str, algo_id: &str, after: &str, before: &str, limit: &str) -> Result<models::TradingBotSignalPositionsHistoryGet200Response, Error<TradingBotSignalPositionsHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_algo_id = algo_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/signal/positions-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    req_builder = req_builder.query(&[("after", &p_after.to_string())]);
    req_builder = req_builder.query(&[("before", &p_before.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalPositionsHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_set_instruments_post(configuration: &configuration::Configuration, instrument_request: Option<models::InstrumentRequest>) -> Result<models::TradingBotGridAdjustInvestmentPost200Response, Error<TradingBotSignalSetInstrumentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instrument_request = instrument_request;

    let uri_str = format!("{}/tradingBot/signal/set-instruments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_instrument_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalSetInstrumentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_signals_get(configuration: &configuration::Configuration, signal_source_type: &str, signal_chan_id: Option<&str>, after: Option<String>, before: Option<String>, limit: Option<&str>) -> Result<models::TradingBotSignalSignalsGet200Response, Error<TradingBotSignalSignalsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_signal_source_type = signal_source_type;
    let p_signal_chan_id = signal_chan_id;
    let p_after = after;
    let p_before = before;
    let p_limit = limit;

    let uri_str = format!("{}/tradingBot/signal/signals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("signalSourceType", &p_signal_source_type.to_string())]);
    if let Some(ref param_value) = p_signal_chan_id {
        req_builder = req_builder.query(&[("signalChanId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalSignalsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID + Instrument ID
pub async fn trading_bot_signal_stop_order_algo_post(configuration: &configuration::Configuration, trading_bot_grid_adjust_investment_post200_response_all_of_data_inner: Option<models::TradingBotGridAdjustInvestmentPost200ResponseAllOfDataInner>) -> Result<models::TradingBotSignalOrderAlgoPost200Response, Error<TradingBotSignalStopOrderAlgoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_trading_bot_grid_adjust_investment_post200_response_all_of_data_inner = trading_bot_grid_adjust_investment_post200_response_all_of_data_inner;

    let uri_str = format!("{}/tradingBot/signal/stop-order-algo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_trading_bot_grid_adjust_investment_post200_response_all_of_data_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalStopOrderAlgoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_signal_sub_order_post(configuration: &configuration::Configuration, sub_order_response: Option<models::SubOrderResponse>) -> Result<models::TradingBotSignalSubOrderPost200Response, Error<TradingBotSignalSubOrderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sub_order_response = sub_order_response;

    let uri_str = format!("{}/tradingBot/signal/sub-order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_sub_order_response);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalSubOrderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: UserID
pub async fn trading_bot_signal_sub_orders_get(configuration: &configuration::Configuration, algo_id: &str, algo_ord_type: &str, state: Option<&str>, signal_ord_id: Option<&str>, after: Option<&str>, before: Option<&str>, begin: Option<&str>, end: Option<&str>, limit: Option<i32>, r#type: Option<&str>, cl_ord_id: Option<&str>) -> Result<models::TradingBotSignalSubOrdersGet200Response, Error<TradingBotSignalSubOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_algo_id = algo_id;
    let p_algo_ord_type = algo_ord_type;
    let p_state = state;
    let p_signal_ord_id = signal_ord_id;
    let p_after = after;
    let p_before = before;
    let p_begin = begin;
    let p_end = end;
    let p_limit = limit;
    let p_type = r#type;
    let p_cl_ord_id = cl_ord_id;

    let uri_str = format!("{}/tradingBot/signal/sub-orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("algoId", &p_algo_id.to_string())]);
    req_builder = req_builder.query(&[("algoOrdType", &p_algo_ord_type.to_string())]);
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_signal_ord_id {
        req_builder = req_builder.query(&[("signalOrdId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cl_ord_id {
        req_builder = req_builder.query(&[("clOrdId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TradingBotSignalSubOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

