/*
 * OKX API
 *
 * Welcome to OKX Developer document!   excluded below endpoints as they are if you need them please add and commit to https://github.com/kanekoshoyu/exchange-collection): - Trading Account (this might become needed, will add when we need it) - Block Trading - Financial Producer - Affiliate - Status - Announcement 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`rubik_stat_contracts_long_short_account_ratio_contract_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatContractsLongShortAccountRatioContractGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_contracts_long_short_account_ratio_contract_top_trader_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatContractsLongShortAccountRatioContractTopTraderGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_contracts_long_short_account_ratio_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatContractsLongShortAccountRatioGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_contracts_long_short_position_ratio_contract_top_trader_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatContractsLongShortPositionRatioContractTopTraderGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_contracts_open_interest_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatContractsOpenInterestHistoryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_contracts_open_interest_volume_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatContractsOpenInterestVolumeGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_margin_loan_ratio_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatMarginLoanRatioGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_option_open_interest_volume_expiry_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatOptionOpenInterestVolumeExpiryGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_option_open_interest_volume_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatOptionOpenInterestVolumeGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_option_open_interest_volume_ratio_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatOptionOpenInterestVolumeRatioGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_option_open_interest_volume_strike_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatOptionOpenInterestVolumeStrikeGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_option_taker_block_volume_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatOptionTakerBlockVolumeGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_taker_volume_contract_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatTakerVolumeContractGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_taker_volume_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatTakerVolumeGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rubik_stat_trading_data_support_coin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RubikStatTradingDataSupportCoinGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Retrieve the account long/short ratio of a contract. This endpoint can retrieve the latest 1,440 data entries.<br>For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_contracts_long_short_account_ratio_contract_get(configuration: &configuration::Configuration, inst_id: &str, begin: Option<&str>, end: Option<&str>, period: Option<&str>, limit: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatContractsLongShortAccountRatioContractGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_begin = begin;
    let p_end = end;
    let p_period = period;
    let p_limit = limit;

    let uri_str = format!("{}/rubik/stat/contracts/long-short-account-ratio-contract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatContractsLongShortAccountRatioContractGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the account net long/short ratio of a contract for top traders. Top traders refer to the top 5% of traders with the largest open position value. This endpoint can retrieve the latest 1,440 data entries. The data time range is up to March 22, 2024.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_contracts_long_short_account_ratio_contract_top_trader_get(configuration: &configuration::Configuration, ccy: &str, begin: Option<&str>, end: Option<&str>, period: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatContractsLongShortAccountRatioContractTopTraderGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_begin = begin;
    let p_end = end;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/contracts/long-short-account-ratio-contract-top-trader", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatContractsLongShortAccountRatioContractTopTraderGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the account long/short ratio of a contract. This endpoint can retrieve the latest 1,440 data entries.<br>For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_contracts_long_short_account_ratio_get(configuration: &configuration::Configuration, ccy: &str, begin: Option<&str>, end: Option<&str>, period: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatContractsLongShortAccountRatioGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_begin = begin;
    let p_end = end;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/contracts/long-short-account-ratio", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatContractsLongShortAccountRatioGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the position long/short ratio of a contract for top traders. Top traders refer to the top 5% of traders with the largest open position value. This endpoint can retrieve the latest 1,440 data entries. The data time range is up to March 22, 2024.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_contracts_long_short_position_ratio_contract_top_trader_get(configuration: &configuration::Configuration, inst_id: &str, begin: Option<&str>, end: Option<&str>, period: Option<&str>, limit: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatContractsLongShortPositionRatioContractTopTraderGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_begin = begin;
    let p_end = end;
    let p_period = period;
    let p_limit = limit;

    let uri_str = format!("{}/rubik/stat/contracts/long-short-position-ratio-contract-top-trader", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatContractsLongShortPositionRatioContractTopTraderGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the contract open interest statistics of futures and perp. This endpoint can retrieve the latest 1,440 data entries.<br>For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024..<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_contracts_open_interest_history_get(configuration: &configuration::Configuration, inst_id: &str, period: Option<&str>, end: Option<&str>, begin: Option<&str>, limit: Option<&str>) -> Result<models::RubikStatContractsOpenInterestHistoryGet200Response, Error<RubikStatContractsOpenInterestHistoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_period = period;
    let p_end = end;
    let p_begin = begin;
    let p_limit = limit;

    let uri_str = format!("{}/rubik/stat/contracts/open-interest-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatContractsOpenInterestHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the open interest and trading volume for Expiry Futures and Perpetual Futures.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_contracts_open_interest_volume_get(configuration: &configuration::Configuration, ccy: &str, begin: Option<&str>, end: Option<&str>, period: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatContractsOpenInterestVolumeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_begin = begin;
    let p_end = end;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/contracts/open-interest-volume", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatContractsOpenInterestVolumeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the contract taker volume for both buyers and sellers. This endpoint can retrieve the latest 1,440 data entries.<br>For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_margin_loan_ratio_get(configuration: &configuration::Configuration, ccy: &str, begin: Option<&str>, end: Option<&str>, period: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatMarginLoanRatioGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_begin = begin;
    let p_end = end;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/margin/loan-ratio", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatMarginLoanRatioGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_option_open_interest_volume_expiry_get(configuration: &configuration::Configuration, ccy: &str, period: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatOptionOpenInterestVolumeExpiryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/option/open-interest-volume-expiry", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatOptionOpenInterestVolumeExpiryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_option_open_interest_volume_get(configuration: &configuration::Configuration, ccy: &str, exp_time: &str, period: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatOptionOpenInterestVolumeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_exp_time = exp_time;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/option/open-interest-volume", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    req_builder = req_builder.query(&[("expTime", &p_exp_time.to_string())]);
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatOptionOpenInterestVolumeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_option_open_interest_volume_ratio_get(configuration: &configuration::Configuration, ccy: &str, period: Option<&str>) -> Result<models::MarketSprdCandlesGet200Response, Error<RubikStatOptionOpenInterestVolumeRatioGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/option/open-interest-volume-ratio", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatOptionOpenInterestVolumeRatioGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_option_open_interest_volume_strike_get(configuration: &configuration::Configuration, ccy: &str, period: Option<&str>) -> Result<models::RubikStatOptionOpenInterestVolumeStrikeGet200Response, Error<RubikStatOptionOpenInterestVolumeStrikeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/option/open-interest-volume-strike", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatOptionOpenInterestVolumeStrikeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This shows the relative buy/sell volume for calls and puts. It shows whether traders are bullish or bearish on price and volatility.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_option_taker_block_volume_get(configuration: &configuration::Configuration, ccy: &str, period: Option<&str>) -> Result<models::RubikStatOptionOpenInterestVolumeStrikeGet200Response, Error<RubikStatOptionTakerBlockVolumeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/option/taker-block-volume", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatOptionTakerBlockVolumeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the contract taker volume for both buyers and sellers. This endpoint can retrieve the latest 1,440 data entries.<br>For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_taker_volume_contract_get(configuration: &configuration::Configuration, inst_id: &str, period: Option<&str>, unit: Option<&str>, end: Option<&str>, begin: Option<&str>, limit: Option<&str>) -> Result<models::RubikStatTakerVolumeGet200Response, Error<RubikStatTakerVolumeContractGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inst_id = inst_id;
    let p_period = period;
    let p_unit = unit;
    let p_end = end;
    let p_begin = begin;
    let p_limit = limit;

    let uri_str = format!("{}/rubik/stat/taker-volume-contract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instId", &p_inst_id.to_string())]);
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unit {
        req_builder = req_builder.query(&[("unit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatTakerVolumeContractGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the taker volume for both buyers and sellers.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_taker_volume_get(configuration: &configuration::Configuration, ccy: &str, inst_type: &str, begin: Option<&str>, end: Option<&str>, period: Option<&str>) -> Result<models::RubikStatTakerVolumeGet200Response, Error<RubikStatTakerVolumeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ccy = ccy;
    let p_inst_type = inst_type;
    let p_begin = begin;
    let p_end = end;
    let p_period = period;

    let uri_str = format!("{}/rubik/stat/taker-volume", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ccy", &p_ccy.to_string())]);
    req_builder = req_builder.query(&[("instType", &p_inst_type.to_string())]);
    if let Some(ref param_value) = p_begin {
        req_builder = req_builder.query(&[("begin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatTakerVolumeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the currencies supported by the trading statistics endpoints.<br>Rate Limit: 20 requests per 2 seconds<br>Rate limit rule: IP
pub async fn rubik_stat_trading_data_support_coin_get(configuration: &configuration::Configuration, ) -> Result<models::RubikStatTradingDataSupportCoinGet200Response, Error<RubikStatTradingDataSupportCoinGetError>> {

    let uri_str = format!("{}/rubik/stat/trading-data/support-coin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<RubikStatTradingDataSupportCoinGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

