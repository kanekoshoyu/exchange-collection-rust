/*
 * Bitwyre REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`private_account_notifications_trading_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountNotificationsTradingGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_spotbalance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountSpotbalanceGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_spotbalance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountSpotbalancePostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_statement_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountStatementGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_transactions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountTransactionsGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_derivatives_close_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateDerivativesCloseGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_derivatives_reduce_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateDerivativesReduceGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_favorites_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateFavoritesGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_fees_withdrawal_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateFeesWithdrawalGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_cancel_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersCancelDeleteError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_cancel_instrument_instrument_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersCancelInstrumentInstrumentDeleteError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_cancelled_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersCancelledGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_closed_all_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersClosedAllGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_closed_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersClosedGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_histories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersHistoriesGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_info_order_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersInfoOrderIdGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_journey_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersJourneyGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_open_all_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersOpenAllGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_open_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersOpenGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_position_close_instrument_instrument_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersPositionCloseInstrumentInstrumentDeleteError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_positions_close_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersPositionsCloseDeleteError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersPostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_orders_qty_percentage_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateOrdersQtyPercentageGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateTradesGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}


pub async fn private_account_notifications_trading_get(configuration: &configuration::Configuration, nonce: Option<i32>, checksum: Option<i32>, trading_notification_type: Option<i32>, limit: Option<i32>) -> Result<models::PrivateAccountNotificationsTradingGet200Response, Error<PrivateAccountNotificationsTradingGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_trading_notification_type = trading_notification_type;
    let p_limit = limit;

    let uri_str = format!("{}/private/account/notifications/trading", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_trading_notification_type {
        req_builder = req_builder.query(&[("trading_notification_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountNotificationsTradingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_spotbalance_get(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>, use_pagination: Option<bool>, asset: Option<&str>) -> Result<models::PrivateAccountSpotbalanceGet200Response, Error<PrivateAccountSpotbalanceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;
    let p_use_pagination = use_pagination;
    let p_asset = asset;

    let uri_str = format!("{}/private/account/spotbalance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_pagination {
        req_builder = req_builder.query(&[("use_pagination", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_asset {
        req_builder = req_builder.query(&[("asset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountSpotbalanceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_spotbalance_post(configuration: &configuration::Configuration, request_schema: models::RequestSchema) -> Result<models::PrivateAccountSpotbalancePost200Response, Error<PrivateAccountSpotbalancePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/spotbalance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountSpotbalancePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_statement_get(configuration: &configuration::Configuration, nonce: i32, checksum: &str, asset: &str, payload: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::PrivateAccountStatementGet200Response, Error<PrivateAccountStatementGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_asset = asset;
    let p_payload = payload;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/private/account/statement", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("asset", &p_asset.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountStatementGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_transactions_get(configuration: &configuration::Configuration, nonce: i32, checksum: &str, r#type: Option<&str>, assets: Option<&str>, page: Option<i32>, per_page: Option<i32>) -> Result<models::PrivateAccountTransactionsGet200Response, Error<PrivateAccountTransactionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_type = r#type;
    let p_assets = assets;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/private/account/transactions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_assets {
        req_builder = req_builder.query(&[("assets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountTransactionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_derivatives_close_get(configuration: &configuration::Configuration, payload: models::PrivateDerivativesReduceGetPayloadParameter, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateDerivativesReduceGet200Response, Error<PrivateDerivativesCloseGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/derivatives/close", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateDerivativesCloseGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_derivatives_reduce_get(configuration: &configuration::Configuration, payload: models::PrivateDerivativesReduceGetPayloadParameter, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateDerivativesReduceGet200Response, Error<PrivateDerivativesReduceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/derivatives/reduce", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateDerivativesReduceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_favorites_get(configuration: &configuration::Configuration, instrument: Option<Vec<String>>) -> Result<models::PrivateFavoritesGet200Response, Error<PrivateFavoritesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instrument = instrument;

    let uri_str = format!("{}/private/favorites", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_instrument {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("instrument".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("instrument", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateFavoritesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_fees_withdrawal_get(configuration: &configuration::Configuration, nonce: i32, checksum: &str, payload: models::PrivateFeesWithdrawalGetPayloadParameter) -> Result<models::PrivateFeesWithdrawalGet200Response, Error<PrivateFeesWithdrawalGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/fees/withdrawal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateFeesWithdrawalGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_cancel_delete(configuration: &configuration::Configuration, payload: models::PrivateOrdersCancelDeletePayloadParameter, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersPost200Response, Error<PrivateOrdersCancelDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersCancelDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_cancel_instrument_instrument_delete(configuration: &configuration::Configuration, instrument: &str, payload: models::PrivateOrdersCancelDeletePayloadParameter, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersPost200Response, Error<PrivateOrdersCancelInstrumentInstrumentDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instrument = instrument;
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/cancel/instrument/{instrument}", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersCancelInstrumentInstrumentDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_cancelled_get(configuration: &configuration::Configuration, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersCancelledGet200Response, Error<PrivateOrdersCancelledGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/cancelled", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersCancelledGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_closed_all_get(configuration: &configuration::Configuration, payload: models::PrivateOrdersOpenGetPayloadParameter, page: Option<i32>, per_page: Option<i32>) -> Result<models::PrivateOrdersOpenGet200Response, Error<PrivateOrdersClosedAllGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/private/orders/closed/all", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersClosedAllGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_closed_get(configuration: &configuration::Configuration, payload: models::PrivateOrdersOpenGetPayloadParameter, page: Option<i32>, per_page: Option<i32>) -> Result<models::PrivateOrdersOpenGet200Response, Error<PrivateOrdersClosedGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/private/orders/closed", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersClosedGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_histories_get(configuration: &configuration::Configuration, payload: models::PrivateOrdersHistoriesGetPayloadParameter, page: i32, per_page: i32, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersHistoriesGet200Response, Error<PrivateOrdersHistoriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_page = page;
    let p_per_page = per_page;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/histories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    req_builder = req_builder.query(&[("page", &p_page.to_string())]);
    req_builder = req_builder.query(&[("per_page", &p_per_page.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersHistoriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_info_order_id_get(configuration: &configuration::Configuration, order_id: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersPost200Response, Error<PrivateOrdersInfoOrderIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/info/{order_id}", configuration.base_path, order_id=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersInfoOrderIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_journey_get(configuration: &configuration::Configuration, payload: models::PrivateOrdersJourneyGetPayloadParameter, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersJourneyGet200Response, Error<PrivateOrdersJourneyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/journey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersJourneyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_open_all_get(configuration: &configuration::Configuration, payload: models::PrivateOrdersOpenGetPayloadParameter, page: Option<i32>, per_page: Option<i32>) -> Result<models::PrivateOrdersOpenGet200Response, Error<PrivateOrdersOpenAllGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/private/orders/open/all", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersOpenAllGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_open_get(configuration: &configuration::Configuration, payload: models::PrivateOrdersOpenGetPayloadParameter, page: Option<i32>, per_page: Option<i32>) -> Result<models::PrivateOrdersOpenGet200Response, Error<PrivateOrdersOpenGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/private/orders/open", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersOpenGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_position_close_instrument_instrument_delete(configuration: &configuration::Configuration, instrument: &str, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersPost200Response, Error<PrivateOrdersPositionCloseInstrumentInstrumentDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instrument = instrument;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/position/close/instrument/{instrument}", configuration.base_path, instrument=crate::apis::urlencode(p_instrument));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersPositionCloseInstrumentInstrumentDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_positions_close_delete(configuration: &configuration::Configuration, payload: models::PrivateOrdersPositionsCloseDeletePayloadParameter, nonce: Option<i32>, checksum: Option<i32>) -> Result<models::PrivateOrdersPost200Response, Error<PrivateOrdersPositionsCloseDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/orders/positions/close", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersPositionsCloseDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_post(configuration: &configuration::Configuration, request_schema: models::RequestSchema) -> Result<models::PrivateOrdersPost200Response, Error<PrivateOrdersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_orders_qty_percentage_get(configuration: &configuration::Configuration, order_type: i32, order_side: i32, instrument: &str, price: Option<&str>) -> Result<models::PrivateOrdersQtyPercentageGet200Response, Error<PrivateOrdersQtyPercentageGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_type = order_type;
    let p_order_side = order_side;
    let p_instrument = instrument;
    let p_price = price;

    let uri_str = format!("{}/private/orders/qty_percentage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("order_type", &p_order_type.to_string())]);
    req_builder = req_builder.query(&[("order_side", &p_order_side.to_string())]);
    req_builder = req_builder.query(&[("instrument", &p_instrument.to_string())]);
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateOrdersQtyPercentageGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_trades_get(configuration: &configuration::Configuration, payload: models::PrivateTradesGetPayloadParameter, nonce: Option<i32>, checksum: Option<i32>, page: Option<i32>, per_page: Option<i32>) -> Result<models::PublicInsiderTradesGet200Response, Error<PrivateTradesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payload = payload;
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/private/trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_checksum {
        req_builder = req_builder.query(&[("checksum", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateTradesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

