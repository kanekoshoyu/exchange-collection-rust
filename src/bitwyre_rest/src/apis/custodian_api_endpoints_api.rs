/*
 * Bitwyre REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`private_account_banking_get_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountBankingGetGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_banking_post_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountBankingPostPostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_deposit_crypto_asset_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountDepositCryptoAssetAddressGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_deposit_crypto_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountDepositCryptoPostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_deposit_fiat_asset_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountDepositFiatAssetAddressGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_deposit_fiat_asset_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountDepositFiatAssetGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_deposit_fiat_request_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountDepositFiatRequestPostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_deposit_gateway_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountDepositGatewayGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoAddressGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_address_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoAddressPatchError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_address_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoAddressPostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_address_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoAddressPutError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_asset_withdrawal_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoAssetWithdrawalIdGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_crypto_withdrawal_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoCryptoWithdrawalIdDeleteError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoPostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_crypto_verify_withdrawal_id_verification_uuid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalCryptoVerifyWithdrawalIdVerificationUuidGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_fiat_asset_withdrawal_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalFiatAssetWithdrawalIdGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_fiat_fiat_withdrawal_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalFiatFiatWithdrawalIdDeleteError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_fiat_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalFiatPostError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawal_fiat_verify_withdrawal_id_verification_uuid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawalFiatVerifyWithdrawalIdVerificationUuidGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`private_account_withdrawl_gateway_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrivateAccountWithdrawlGatewayGetError {
    Status500(),
    Status400(),
    Status401(),
    Status404(),
    Status405(),
    Status406(),
    Status410(),
    Status418(),
    Status422(),
    Status429(),
    Status503(),
    UnknownValue(serde_json::Value),
}


pub async fn private_account_banking_get_get(configuration: &configuration::Configuration, nonce: i32, checksum: &str) -> Result<models::PrivateAccountBankingGetGet200Response, Error<PrivateAccountBankingGetGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;

    let uri_str = format!("{}/private/account/banking/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountBankingGetGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_banking_post_post(configuration: &configuration::Configuration, request_schema: Option<models::RequestSchema>) -> Result<models::PrivateAccountWithdrawalCryptoAddressPut200Response, Error<PrivateAccountBankingPostPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/banking/post", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountBankingPostPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_deposit_crypto_asset_address_get(configuration: &configuration::Configuration, asset: &str, address: &str, nonce: i32, checksum: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter) -> Result<models::PrivateAccountDepositCryptoAssetAddressGet200Response, Error<PrivateAccountDepositCryptoAssetAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset = asset;
    let p_address = address;
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/deposit/crypto/{asset}/{address}", configuration.base_path, asset=crate::apis::urlencode(p_asset), address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountDepositCryptoAssetAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_deposit_crypto_post(configuration: &configuration::Configuration, request_schema: models::RequestSchema) -> Result<models::PrivateAccountDepositCryptoPost200Response, Error<PrivateAccountDepositCryptoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/deposit/crypto", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountDepositCryptoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_deposit_fiat_asset_address_get(configuration: &configuration::Configuration, asset: &str, address: &str, nonce: i32, checksum: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter) -> Result<models::PrivateAccountDepositFiatAssetAddressGet200Response, Error<PrivateAccountDepositFiatAssetAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset = asset;
    let p_address = address;
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/deposit/fiat/{asset}/{address}", configuration.base_path, asset=crate::apis::urlencode(p_asset), address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountDepositFiatAssetAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_deposit_fiat_asset_get(configuration: &configuration::Configuration, asset: &str) -> Result<models::PrivateAccountDepositFiatAssetGet200Response, Error<PrivateAccountDepositFiatAssetGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset = asset;

    let uri_str = format!("{}/private/account/deposit/fiat/{asset}", configuration.base_path, asset=crate::apis::urlencode(p_asset));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountDepositFiatAssetGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_deposit_fiat_request_post(configuration: &configuration::Configuration, request_schema: models::RequestSchema) -> Result<models::PrivateAccountDepositFiatRequestPost200Response, Error<PrivateAccountDepositFiatRequestPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/deposit/fiat/request", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountDepositFiatRequestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_deposit_gateway_get(configuration: &configuration::Configuration, nonce: i32, checksum: &str, payload: models::PrivateAccountDepositGatewayGetPayloadParameter) -> Result<models::PrivateAccountDepositGatewayGet200Response, Error<PrivateAccountDepositGatewayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/deposit/gateway", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountDepositGatewayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_withdrawal_crypto_address_get(configuration: &configuration::Configuration, nonce: i32, checksum: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter) -> Result<models::PrivateAccountWithdrawalCryptoAddressGet200Response, Error<PrivateAccountWithdrawalCryptoAddressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/withdrawal/crypto/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoAddressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_withdrawal_crypto_address_patch(configuration: &configuration::Configuration, request_schema: Option<models::RequestSchema>) -> Result<models::PrivateAccountWithdrawalCryptoAddressPut200Response, Error<PrivateAccountWithdrawalCryptoAddressPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/withdrawal/crypto/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoAddressPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Same requestbody and endpoint with DELETE method can be used to delete crypto address.
pub async fn private_account_withdrawal_crypto_address_post(configuration: &configuration::Configuration, request_schema: Option<models::RequestSchema>) -> Result<models::PrivateAccountWithdrawalCryptoAddressPut200Response, Error<PrivateAccountWithdrawalCryptoAddressPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/withdrawal/crypto/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoAddressPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_withdrawal_crypto_address_put(configuration: &configuration::Configuration, request_schema: Option<models::RequestSchema>) -> Result<models::PrivateAccountWithdrawalCryptoAddressPut200Response, Error<PrivateAccountWithdrawalCryptoAddressPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/withdrawal/crypto/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoAddressPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_withdrawal_crypto_asset_withdrawal_id_get(configuration: &configuration::Configuration, withdrawal_id: &str, asset: &str, nonce: i32, checksum: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter) -> Result<models::PrivateAccountWithdrawalCryptoAssetWithdrawalIdGet200Response, Error<PrivateAccountWithdrawalCryptoAssetWithdrawalIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdrawal_id = withdrawal_id;
    let p_asset = asset;
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/withdrawal/crypto/{asset}/{withdrawal_id}", configuration.base_path, withdrawal_id=crate::apis::urlencode(p_withdrawal_id), asset=crate::apis::urlencode(p_asset));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoAssetWithdrawalIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// We conduct crypto withdrawal transfers 4 times a day 6:00 Jakarta/WIB, 12:00 Jakarta/WIB, 18:00 Jakarta/WIB, 00:00 Jakarta/WIB. A cancel pending withdrawal for crypto operation can only be done 1 hour before those designated withdrawal times.<br>For example, for the withdrawal batch of 6:00 Jakarta/WIB, the cancel time window closes on 5:00 Jakarta/WIB.<br>Any attempt to cancel a withdrawal after the cancel time window is rejected and will be returned a status of \"cancel rejected\" and be automatically processed on the next batch.
pub async fn private_account_withdrawal_crypto_crypto_withdrawal_id_delete(configuration: &configuration::Configuration, crypto: &str, withdrawal_id: &str, nonce: i32, checksum: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter) -> Result<models::PrivateAccountWithdrawalCryptoCryptoWithdrawalIdDelete200Response, Error<PrivateAccountWithdrawalCryptoCryptoWithdrawalIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_crypto = crypto;
    let p_withdrawal_id = withdrawal_id;
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/withdrawal/crypto/{crypto}/{withdrawal_id}", configuration.base_path, crypto=crate::apis::urlencode(p_crypto), withdrawal_id=crate::apis::urlencode(p_withdrawal_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoCryptoWithdrawalIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new withdrawal request for a given asset with the given amount.<br>A confirmation email will be sent and contains instruction on how to confirm the withdrawal request.<br>The transaction will not be processed before a confirmation is conducted.
pub async fn private_account_withdrawal_crypto_post(configuration: &configuration::Configuration, request_schema: models::RequestSchema) -> Result<models::PrivateAccountWithdrawalCryptoPost200Response, Error<PrivateAccountWithdrawalCryptoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/withdrawal/crypto", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new withdrawal request for a given asset with the given amount.<br>A confirmation email will be sent and contains instruction on how to confirm the withdrawal request.<br>The transaction will not be processed before a confirmation is conducted.
pub async fn private_account_withdrawal_crypto_verify_withdrawal_id_verification_uuid_get(configuration: &configuration::Configuration, withdrawal_id: &str, verification_uuid: &str) -> Result<models::PrivateAccountWithdrawalCryptoVerifyWithdrawalIdVerificationUuidGet200Response, Error<PrivateAccountWithdrawalCryptoVerifyWithdrawalIdVerificationUuidGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdrawal_id = withdrawal_id;
    let p_verification_uuid = verification_uuid;

    let uri_str = format!("{}/private/account/withdrawal/crypto/verify/{withdrawal_id}/{verification_uuid}", configuration.base_path, withdrawal_id=crate::apis::urlencode(p_withdrawal_id), verification_uuid=crate::apis::urlencode(p_verification_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalCryptoVerifyWithdrawalIdVerificationUuidGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_withdrawal_fiat_asset_withdrawal_id_get(configuration: &configuration::Configuration, withdrawal_id: &str, asset: &str, nonce: i32, checksum: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter) -> Result<models::PrivateAccountWithdrawalCryptoAssetWithdrawalIdGet200Response, Error<PrivateAccountWithdrawalFiatAssetWithdrawalIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdrawal_id = withdrawal_id;
    let p_asset = asset;
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/withdrawal/fiat/{asset}/{withdrawal_id}", configuration.base_path, withdrawal_id=crate::apis::urlencode(p_withdrawal_id), asset=crate::apis::urlencode(p_asset));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalFiatAssetWithdrawalIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// We conduct fiat withdrawal transfers 1 time a day 9:00 Jakarta/WIB. A cancel pending withdrawal for fiat operation can only be done 24 hours before those designated withdrawal times.<br>For example, for the withdrawal batch of 9:00 Jakarta/WIB, the cancel time window closes on 8:59 Jakarta/WIB the previous day<br>Any attempt to cancel a withdrawal after the cancel time window is rejected and will be returned a status of \"cancel rejected\" and be automatically processed on the next batch.
pub async fn private_account_withdrawal_fiat_fiat_withdrawal_id_delete(configuration: &configuration::Configuration, fiat: &str, withdrawal_id: &str, nonce: i32, checksum: &str, payload: models::PrivateOrdersInfoOrderIdGetPayloadParameter) -> Result<models::PrivateAccountWithdrawalCryptoCryptoWithdrawalIdDelete200Response, Error<PrivateAccountWithdrawalFiatFiatWithdrawalIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fiat = fiat;
    let p_withdrawal_id = withdrawal_id;
    let p_nonce = nonce;
    let p_checksum = checksum;
    let p_payload = payload;

    let uri_str = format!("{}/private/account/withdrawal/fiat/{fiat}/{withdrawal_id}", configuration.base_path, fiat=crate::apis::urlencode(p_fiat), withdrawal_id=crate::apis::urlencode(p_withdrawal_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("nonce", &p_nonce.to_string())]);
    req_builder = req_builder.query(&[("checksum", &p_checksum.to_string())]);
    req_builder = req_builder.query(&[("payload", &p_payload.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalFiatFiatWithdrawalIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new withdrawal request for a given asset with the given amount.<br>A confirmation email will be sent and contains instruction on how to confirm the withdrawal request.<br>The transaction will not be processed before a confirmation is conducted.
pub async fn private_account_withdrawal_fiat_post(configuration: &configuration::Configuration, request_schema: models::RequestSchema) -> Result<models::PrivateAccountWithdrawalFiatPost200Response, Error<PrivateAccountWithdrawalFiatPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_schema = request_schema;

    let uri_str = format!("{}/private/account/withdrawal/fiat", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };
    req_builder = req_builder.json(&p_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalFiatPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new fiat request for a given asset with the given amount.<br>A confirmation email will be sent and contains instruction on how to confirm the withdrawal request.<br>The transaction will not be processed before a confirmation is conducted.
pub async fn private_account_withdrawal_fiat_verify_withdrawal_id_verification_uuid_get(configuration: &configuration::Configuration, withdrawal_id: &str, verification_uuid: &str) -> Result<models::PrivateAccountWithdrawalCryptoVerifyWithdrawalIdVerificationUuidGet200Response, Error<PrivateAccountWithdrawalFiatVerifyWithdrawalIdVerificationUuidGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_withdrawal_id = withdrawal_id;
    let p_verification_uuid = verification_uuid;

    let uri_str = format!("{}/private/account/withdrawal/fiat/verify/{withdrawal_id}/{verification_uuid}", configuration.base_path, withdrawal_id=crate::apis::urlencode(p_withdrawal_id), verification_uuid=crate::apis::urlencode(p_verification_uuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawalFiatVerifyWithdrawalIdVerificationUuidGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn private_account_withdrawl_gateway_get(configuration: &configuration::Configuration, ) -> Result<models::PrivateAccountDepositGatewayGet200Response, Error<PrivateAccountWithdrawlGatewayGetError>> {

    let uri_str = format!("{}/private/account/withdrawl/gateway", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-KEY", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-API-SIGN", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PrivateAccountWithdrawlGatewayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

